<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jason&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://sunlanchang.github.io/"/>
  <updated>2017-12-14T13:46:15.800Z</updated>
  <id>http://sunlanchang.github.io/</id>
  
  <author>
    <name>Jason Sun</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>存储系统</title>
    <link href="http://sunlanchang.github.io/2017/12/14/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/"/>
    <id>http://sunlanchang.github.io/2017/12/14/存储系统/</id>
    <published>2017-12-14T12:58:55.000Z</published>
    <updated>2017-12-14T13:46:15.800Z</updated>
    
    <content type="html"><![CDATA[<h1 id="三层体系结构的特点"><a href="#三层体系结构的特点" class="headerlink" title="三层体系结构的特点"></a>三层体系结构的特点</h1><p>三层体系结构依次是：Cache、主存、辅存。  </p><ul><li>cache-主存:在CPU和主存之间增加一级速度快、但容量较小且每位价格较高的高速缓冲存储Cache)。借助于辅助软硬件，它与主存构成一个有机的整体，以弥补主存速度的不足。这个层次的工作主要由硬件实现。  </li><li>主存-辅存:这个层次的目的是为了弥补主存容量的它是在主存外面增加一个容量更大、每位价格更速度更慢的存储器(称为辅存，一般是硬盘)。它辅助软硬件的作用，构成一个整体。“主存-辅存常被用来实现虚拟存储器，向编程人员提供大量空间。<h1 id="Cache的特点、作用、工作原理"><a href="#Cache的特点、作用、工作原理" class="headerlink" title="Cache的特点、作用、工作原理"></a>Cache的特点、作用、工作原理</h1></li></ul><ol><li>特点是速度快</li><li>作用：弥补CPU与主存之间的运行速度的差距。</li><li>工作原理：根据数据分布的局部性和时间局部性在CPU和主存之间设置Cache。 <h1 id="虚拟存储器的特点、工作原理、管理方式"><a href="#虚拟存储器的特点、工作原理、管理方式" class="headerlink" title="虚拟存储器的特点、工作原理、管理方式"></a>虚拟存储器的特点、工作原理、管理方式</h1>虚拟存储器指的是“主存-辅存”层次。</li></ol><p><strong>段式</strong>  </p><ol><li>段式存储是根据程序逻辑，给程序分段。使得每段大小不同。这种虚拟地址划分方法适合程序设计</li><li>段式存储的虚拟地址由段号和段内偏移地址组成。段式虚拟存储器到物理地址的映射通过段表实现</li><li>段式虚拟存储会造成空页</li></ol><p><strong>页式</strong>  </p><ol><li>概念<ol><li>程序员在比实际主存大得多的逻辑地址空间中编写程序</li><li>程序执行时，把当前需要的程序段和数据块掉入主存，其他暂不使用的放在磁盘上</li><li>执行指令时，通过硬件将逻辑地址转化为物理地址。虚拟地址高位为虚页号，低位为页内偏移地址</li><li>当程序发生数据访问或程序访问失效(缺页时)，由操作系统把信息从磁盘调入主存中</li></ol></li><li>分页  <ol><li>基本思想：内存被分成固定长度且长度较小的存储块（页框，实页，物理页），每个进程也被划分为固定长度的程序块（页，虚页，逻辑页），通过页表，实现逻辑地址想物理地址转化</li><li>逻辑地址：程序中指令所使用的地址（进程所在地址空间）</li><li>物理地址：存放指令或数据的实际内存地址</li></ol></li><li>页表结构<br>页表的首地址放在基址寄存器。采用基址寻址方式<br>每个页表项前面有一个虚页号：从0开始递增的序号。页表项又分为几个结构：<br>（1）装入位：该页是否在内存中<br>（2）修改位：该也在内存中是否被修改<br>（3）替换控制位：用于clock算法<br>（4）其他<br>（5）实页号（8进制）<br><strong>段页式</strong>  </li><li>段页式虚拟存储，先把程序按照逻辑分成段，再把每段分成固定大小的页。<br>程序对主存的调入调出是按照页面进行的。但他有可以根据段实现共享和保护。</li><li>缺点是段页式虚拟地址转换成物理地址需要查询2个表：段表和页表。段表找到相应页表的位置，页表找到想也页的位置。</li><li>段页式细腻地址的结构可以为以下形式：<br>程序地址： <code>用户号(进程pid) | 段号 | 页号 | 页内偏移地址</code><h1 id="Cache的地址映像"><a href="#Cache的地址映像" class="headerlink" title="Cache的地址映像"></a>Cache的地址映像</h1><strong>直接映像</strong><br>j= i mod Cache的块数<br>把主存分成若干区，每区与Cache大小相同。区内分块，主存每个区中块的大小和Cache中块的大小相等，主存中每个区包含的块的个数与Cache中块的个数相等。任意一个主存块只能映像到Cache中唯一指定的块中，即相同块号的位置。主存地址分为三部分：区号、块号和块内地址，Cache地址分为：块号和块内地址。直接映像方式下，数据块只能映像到Cache中唯一指定的位置，故不存在替换算法的问题。它不同于全相连Cache，地址仅需比较一次。<br>特点：地址变换简单、速度快，可直接由主存地址提取出Cache地址。但不灵活，块冲突率较高，Cache空间得不到充分利用。<br>公式：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">主存地址位数 ＝ 区号 + 区内分块号 + 块内地址</div><div class="line">Cache地址位数 ＝ 块号+块内地址</div></pre></td></tr></table></figure></li></ol><p><strong>全相联映像</strong><br>计算主存地址的各字段的位数、命中率。<br>主存中任何一个块均可以映像装入到Cache中的任何一个块的位置上。主存地址分为块号和块内地址两部分，Cache地址也分为块号和块内地址。Cache的块内地址部分直接取自主存地址的块内地址段。主存块号和Cache块号不相同，Cache块号根据主存块号从块表中查找。Cache保存的各数据块互不相关，Cache必须对每个块和块自身的地址加以存储。当请求数据时，Cache控制器要把请求地址同所有的地址加以比较，进行确认。<br>特点：灵活，块冲突率低，只有在Cache中的块全部装满后才会出现冲突，Cache利用率高。但地址变换机构复杂，地址变换速度慢，成本高。<br>公式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">主存地址位数 ＝ 块号 + 块内地址</div><div class="line">Cache地址位数＝块号 + 块内地址。</div></pre></td></tr></table></figure></p><p><strong>组相联映像</strong><br>j=(i mod Cache的组数)×Cache每组块数+k<br>组相连映像是前两种方式的折衷。主存按Cache容量分区，每个区分为若干组，每组包含若干块。Cache也进行同样的分组和分块。主存中一个组内的块数与Cache中一个组内的块数相等。组间采用直接方式，组内采用全相连方式。组的容量＝1时，即直接映像，组的容量＝整个Cache的容量时，即全相连映像。Cache的存在对于程序员透明，Cache的地址变换和数据块的替换算法都采用硬件实现。<br>公式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">主存地址位数 ＝ 区号 + 组号 + 主存块号 + 块内地址</div><div class="line">Cache地址位数 ＝ 组号 + 组内块号 + 块内地址</div></pre></td></tr></table></figure></p><h1 id="替换策略（FIFO和LRU）"><a href="#替换策略（FIFO和LRU）" class="headerlink" title="替换策略（FIFO和LRU）"></a>替换策略（FIFO和LRU）</h1><p>略</p><h1 id="设置了Cache与未设置Cache时计算机运行速度的计算、内存平均存取时间的计算。"><a href="#设置了Cache与未设置Cache时计算机运行速度的计算、内存平均存取时间的计算。" class="headerlink" title="设置了Cache与未设置Cache时计算机运行速度的计算、内存平均存取时间的计算。"></a>设置了Cache与未设置Cache时计算机运行速度的计算、内存平均存取时间的计算。</h1><p>平均存取时间=h<em>tc+(1–h) </em>(tm)</p><h1 id="辅助存储器的性能参数的计算"><a href="#辅助存储器的性能参数的计算" class="headerlink" title="辅助存储器的性能参数的计算"></a>辅助存储器的性能参数的计算</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;三层体系结构的特点&quot;&gt;&lt;a href=&quot;#三层体系结构的特点&quot; class=&quot;headerlink&quot; title=&quot;三层体系结构的特点&quot;&gt;&lt;/a&gt;三层体系结构的特点&lt;/h1&gt;&lt;p&gt;三层体系结构依次是：Cache、主存、辅存。  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;cach
      
    
    </summary>
    
      <category term="计算机组成原理" scheme="http://sunlanchang.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="计算机组成原理" scheme="http://sunlanchang.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>中央处理器</title>
    <link href="http://sunlanchang.github.io/2017/12/14/%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/"/>
    <id>http://sunlanchang.github.io/2017/12/14/中央处理器/</id>
    <published>2017-12-14T12:18:28.000Z</published>
    <updated>2017-12-14T12:56:10.317Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p><strong>程序计数器PC</strong><br>即指令地址寄存器。用来存放当前正在执行的指令地址，或将要执行的下一条指令地址。<br><strong>指令寄存器IR</strong><br>用来存放当前正在执行的指令，以便在指令执行过程中控制完成一条指令的全部功能。<br><strong>指令译码器</strong><br>对指令寄存器IR中的操作码进行分析解释，产生相应的控制信号。<br><strong>MAR、MDR、标志寄存器</strong><br>地址寄存器，数据寄存器。标志寄存器包含CNVZ四个标志位。<br><strong>时钟周期、指令周期、机器周期</strong>  </p><ol><li>时钟周期：是计算机中最基本的、最小的时间单位。在一个时钟周期内,CPU仅完成一个最基本的动作。  </li><li>机器周期：在计算机中,为了便于管理,常把一条指令的执行过程划分为若干个阶段,每一阶段完成一项工作。例如,取指令、存储器读、存储器写等,这每一项工作称为一个基本操作。完成一个基本操作所需要的时间称为机器周期。  </li><li>指令周期：执行一条指令所需要的时间,一般由若干个机器周期组成。指令不同,所需的机器周期也不同。       对于一些简单的的单字节指令,在取指令周期中,指令取出到指令寄存器后,立即译码执行,不再需要其它的机器周期。对于一些比较复杂的指令,例如转移指令、乘法指令,则需要两个或者两个以上的机器周期。    通常含一个机器周期的指令称为单周期指令,包含两个机器周期的指令称为双周期指令。  </li></ol><p><strong>控制存储器</strong><br>为程序一般存放在专用的存储器中，该存储器主要存放控制命令（信号）和下一条执行的微指令地址（下址）。执行一条微指令就是执行一段存放在控制存储器中的微程序。</p><h1 id="控制器产生控制信号有两种方法：微程序控制、硬布线控制（组合逻辑控制）"><a href="#控制器产生控制信号有两种方法：微程序控制、硬布线控制（组合逻辑控制）" class="headerlink" title="控制器产生控制信号有两种方法：微程序控制、硬布线控制（组合逻辑控制）"></a>控制器产生控制信号有两种方法：微程序控制、硬布线控制（组合逻辑控制）</h1><p>略</p><h1 id="计算机取指和取操作数的过程及数据通路"><a href="#计算机取指和取操作数的过程及数据通路" class="headerlink" title="计算机取指和取操作数的过程及数据通路"></a>计算机取指和取操作数的过程及数据通路</h1><p>略</p><h1 id="用微程序设计方案设计微指令的控制字段（直接控制方式和直接编译方式）和下址字段。"><a href="#用微程序设计方案设计微指令的控制字段（直接控制方式和直接编译方式）和下址字段。" class="headerlink" title="用微程序设计方案设计微指令的控制字段（直接控制方式和直接编译方式）和下址字段。"></a>用微程序设计方案设计微指令的控制字段（直接控制方式和直接编译方式）和下址字段。</h1><p>略</p><h1 id="指令流水的概念、影响流水线性能的因素及解决方法"><a href="#指令流水的概念、影响流水线性能的因素及解决方法" class="headerlink" title="指令流水的概念、影响流水线性能的因素及解决方法"></a>指令流水的概念、影响流水线性能的因素及解决方法</h1><ol><li>为提高CPU利用率，加快执行速度，将指令分为若干个阶段，可并行执行不同指令的不同阶段，从而多个指令可以同时执行。在有效地控制了流水线阻塞的情况下，流水线可大大提高指令执行速度。经典的五级流水线：取址、译码/读寄存器、执行/计算有效地址、访问内存（读或写）、结果写回寄存器。</li><li>流水线阻塞的情况有三种：<br>　　1. 结构相关：指令重叠执行的过程中，硬件资源满足不了指令重叠执行的要求，发生资源冲突，这时将产生结构相关。解决的办法是增加硬件资源。<br>　　2. 数据相关：当一条指令需要前面某条指令的执行结果，而两者正在并行执行的情况下，将产生数据相关。解决方式：数据重定向，或称为旁路技术。<br>　　3. 控制相关：有跳转语句、分支指令，或其他改变IP值的指令，将产生控制相关。解决方法：分支预测技术，投机执行，延迟分支。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;程序计数器PC&lt;/strong&gt;&lt;br&gt;即指令地址寄存器。用来存放当前正在执行的指令地址，或将要执行的下一条
      
    
    </summary>
    
      <category term="计算机组成原理" scheme="http://sunlanchang.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="计算机组成原理" scheme="http://sunlanchang.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>指令系统</title>
    <link href="http://sunlanchang.github.io/2017/12/14/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/"/>
    <id>http://sunlanchang.github.io/2017/12/14/指令系统/</id>
    <published>2017-12-14T12:03:39.000Z</published>
    <updated>2017-12-14T12:55:52.266Z</updated>
    
    <content type="html"><![CDATA[<h1 id="指令操作码、地址码的设计方法"><a href="#指令操作码、地址码的设计方法" class="headerlink" title="指令操作码、地址码的设计方法"></a>指令操作码、地址码的设计方法</h1><p>略</p><h1 id="常用的寻址方式及其特点"><a href="#常用的寻址方式及其特点" class="headerlink" title="常用的寻址方式及其特点"></a>常用的寻址方式及其特点</h1><p>直接寻址、寄存器寻址、基址寻址、变址寻址、间接寻址（寄存器间址、存储器间址）、相对寻址、立即数寻址。<br>参考：<a href="https://sunlanchang.github.io/2017/11/21/%E5%9B%BE%E8%A7%A3%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F/">图解寻址方式</a></p><h1 id="基本概念：堆栈、标志位、指令字长"><a href="#基本概念：堆栈、标志位、指令字长" class="headerlink" title="基本概念：堆栈、标志位、指令字长"></a>基本概念：堆栈、标志位、指令字长</h1><ol><li>标志位：C（产生进位或借位）、V（结果溢出）、Z（结果为0）、N（结果为负）</li><li>指令字长分为单字长指令和双字长指令。 </li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;指令操作码、地址码的设计方法&quot;&gt;&lt;a href=&quot;#指令操作码、地址码的设计方法&quot; class=&quot;headerlink&quot; title=&quot;指令操作码、地址码的设计方法&quot;&gt;&lt;/a&gt;指令操作码、地址码的设计方法&lt;/h1&gt;&lt;p&gt;略&lt;/p&gt;
&lt;h1 id=&quot;常用的寻址方式及
      
    
    </summary>
    
      <category term="计算机组成原理" scheme="http://sunlanchang.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="计算机组成原理" scheme="http://sunlanchang.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>主存储器</title>
    <link href="http://sunlanchang.github.io/2017/12/14/%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8/"/>
    <id>http://sunlanchang.github.io/2017/12/14/主存储器/</id>
    <published>2017-12-14T11:46:19.000Z</published>
    <updated>2017-12-14T12:02:05.150Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RAM和ROM的特性"><a href="#RAM和ROM的特性" class="headerlink" title="RAM和ROM的特性"></a>RAM和ROM的特性</h1><ol><li>RAM：通过指令可以随机的个别的对各个存储但愿进行访问读写的存储器，访问时间与存储单元的地址无关。停电会造成信息丢失，具有易失性。</li><li>ROM：只能读不能写的存储器，具有非易失性。（ROM不是外部存储器例如硬盘等）</li></ol><h1 id="SRAM、DRAM"><a href="#SRAM、DRAM" class="headerlink" title="SRAM、DRAM"></a>SRAM、DRAM</h1><ol><li>两者都是RAM类型的存储器。</li><li>DRAM容量大，价格便宜，功率小，常用做主存储器的主要元件。</li><li>SRAM速度快，一般用作容量不大的高速存储器（例如高速缓冲存储器Cache）。</li></ol><h1 id="存储器容量的扩展"><a href="#存储器容量的扩展" class="headerlink" title="存储器容量的扩展"></a>存储器容量的扩展</h1><ol><li>字扩展</li><li>位扩展</li><li>字位扩展</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;RAM和ROM的特性&quot;&gt;&lt;a href=&quot;#RAM和ROM的特性&quot; class=&quot;headerlink&quot; title=&quot;RAM和ROM的特性&quot;&gt;&lt;/a&gt;RAM和ROM的特性&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;RAM：通过指令可以随机的个别的对各个存储但愿进行访问读写的存储
      
    
    </summary>
    
      <category term="计算机组成原理" scheme="http://sunlanchang.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="计算机组成原理" scheme="http://sunlanchang.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>计算机运算方法和运算部件</title>
    <link href="http://sunlanchang.github.io/2017/12/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E9%83%A8%E4%BB%B6/"/>
    <id>http://sunlanchang.github.io/2017/12/14/计算机运算方法和运算部件/</id>
    <published>2017-12-14T10:56:44.000Z</published>
    <updated>2017-12-14T11:45:15.330Z</updated>
    
    <content type="html"><![CDATA[<h1 id="十进制数、二进制数、十六进制数的相互转换"><a href="#十进制数、二进制数、十六进制数的相互转换" class="headerlink" title="十进制数、二进制数、十六进制数的相互转换"></a>十进制数、二进制数、十六进制数的相互转换</h1><ol><li>整数十进制转二进制有模2取余法。</li><li>小数转二进制有乘2取整法。</li><li>二进制转十六进制：二进制从低位到高位四个为一组（高位不够补0），转换为十六进制。反之为十六进制转换二进制。</li><li>十进制转十六进制：第一种先把十六进制转换为二进制，再把二进制转换为十六进制。第二种模16取余法，十六进制即为倒序的余数。</li></ol><h1 id="机器数的表示方法：原码、补码、反码、移码"><a href="#机器数的表示方法：原码、补码、反码、移码" class="headerlink" title="机器数的表示方法：原码、补码、反码、移码"></a>机器数的表示方法：原码、补码、反码、移码</h1><ol><li>原码：用0、1取代符号位。0表示正数，1表示负数。与真值最接近的表示形式。</li><li>补码：机器数的最高位为符号位。0表示正数，1表示负数。正数的补码是本身，负数的补码是取反再加1，0的补码是0。</li><li>反码：符号位不变各位取反。</li><li>移码：符号位取反的补码。用来表示浮点数的阶码。</li></ol><h1 id="补码加减法运算时如何采用双符号位取反的补码符号位判溢出"><a href="#补码加减法运算时如何采用双符号位取反的补码符号位判溢出" class="headerlink" title="补码加减法运算时如何采用双符号位取反的补码符号位判溢出"></a>补码加减法运算时如何采用双符号位取反的补码符号位判溢出</h1><h1 id="浮点数表示方法"><a href="#浮点数表示方法" class="headerlink" title="浮点数表示方法"></a>浮点数表示方法</h1><p>$$N=MR^E$$<br>| 尾数符号位（Ms） | 阶码（E） | 尾数（M） |<br>| :————–: | :——-: | :——-: |</p><ol><li>Ms为尾数的符号位，设置在最高位。</li><li>E为阶码，一般为整数，其中有一位符号位，设置在E的最高位，用来表示正阶或负阶。</li><li>M为尾数，为了保证数据精度，尾数通常用规格化（尾数最高位不能为0）表示：当R=2且尾数值不为0时，其绝对值应大于或等于$(0.5)_{10}$。对于非规格化的浮点数通过将尾数左移或右移并修改阶码值使之满足规格化要求。</li></ol><h1 id="奇偶校验码"><a href="#奇偶校验码" class="headerlink" title="奇偶校验码"></a>奇偶校验码</h1><p>数据：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span> </div><div class="line"><span class="number">0</span>  <span class="number">0</span>  <span class="number">1</span> </div><div class="line"><span class="number">1</span>  <span class="number">1</span>  <span class="number">0</span></div></pre></td></tr></table></figure></p><p>积校验<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span> </div><div class="line"><span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">1</span> </div><div class="line"><span class="number">1</span>  <span class="number">1</span>  <span class="number">1</span>  <span class="number">0</span></div></pre></td></tr></table></figure></p><p>偶校验<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span> </div><div class="line"><span class="number">1</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">1</span> </div><div class="line"><span class="number">0</span>  <span class="number">1</span>  <span class="number">1</span>  <span class="number">0</span></div></pre></td></tr></table></figure></p><h1 id="定点数的加减运算；"><a href="#定点数的加减运算；" class="headerlink" title="定点数的加减运算；"></a>定点数的加减运算；</h1><h1 id="补码一位乘：布斯公式法；"><a href="#补码一位乘：布斯公式法；" class="headerlink" title="补码一位乘：布斯公式法；"></a>补码一位乘：布斯公式法；</h1><h1 id="原码一位除：加减交替法；"><a href="#原码一位除：加减交替法；" class="headerlink" title="原码一位除：加减交替法；"></a>原码一位除：加减交替法；</h1><h1 id="浮点数的加减运算（分五个步骤）"><a href="#浮点数的加减运算（分五个步骤）" class="headerlink" title="浮点数的加减运算（分五个步骤）"></a>浮点数的加减运算（分五个步骤）</h1><ol><li>对阶</li><li>尾数加减</li><li>规格化</li><li>舍入</li><li>判溢出</li><li>得到结果</li></ol><h1 id="定点原码数、定点补码数的表示范围-见P67-3-9"><a href="#定点原码数、定点补码数的表示范围-见P67-3-9" class="headerlink" title="定点原码数、定点补码数的表示范围(见P67 3.9)"></a>定点原码数、定点补码数的表示范围(见P67 3.9)</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;十进制数、二进制数、十六进制数的相互转换&quot;&gt;&lt;a href=&quot;#十进制数、二进制数、十六进制数的相互转换&quot; class=&quot;headerlink&quot; title=&quot;十进制数、二进制数、十六进制数的相互转换&quot;&gt;&lt;/a&gt;十进制数、二进制数、十六进制数的相互转换&lt;/h1&gt;&lt;
      
    
    </summary>
    
      <category term="计算机组成原理" scheme="http://sunlanchang.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="计算机组成原理" scheme="http://sunlanchang.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>计算机组成原理系统概论</title>
    <link href="http://sunlanchang.github.io/2017/12/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/"/>
    <id>http://sunlanchang.github.io/2017/12/14/计算机组成原理系统概论/</id>
    <published>2017-12-14T10:30:28.000Z</published>
    <updated>2017-12-14T10:54:58.494Z</updated>
    
    <content type="html"><![CDATA[<h1 id="冯•诺依曼结构计算机的特点"><a href="#冯•诺依曼结构计算机的特点" class="headerlink" title="冯•诺依曼结构计算机的特点"></a>冯•诺依曼结构计算机的特点</h1><ol><li>计算机由运算器、控制器、存储器、输入设备、输出设备组成。</li><li>采用存储程序的方式，程序和数据放在同一个存储器中，并以二进制表示。</li><li>指令由操作码和地址码组成。</li><li>指令在存储器中按执行顺序排放，由指令计数器（即程序计数器PC）指明要执行的指令所在存储单元地址。</li><li>机器以运算器为中心，输入输出设备与存储器之间的数据传送都通过运算器。</li></ol><h1 id="计算机硬件系统的组成"><a href="#计算机硬件系统的组成" class="headerlink" title="计算机硬件系统的组成"></a>计算机硬件系统的组成</h1><p>计算机由运算器、控制器、存储器、输入设备、输出设备组成。  </p><ol><li>运算器是对数据进行处理的运算部件，一般进行算数运算和逻辑运算。</li><li>控制器实现程序的自动执行。</li><li>存储器用来存放程序和数据。</li><li>输入设备用来输入原始数据和处理这些数据的程序。</li><li>输出设备用来输出计算机的处理结果。</li></ol><h1 id="计算机语言：机器语言、汇编语言、高级语言，三种语言的特点"><a href="#计算机语言：机器语言、汇编语言、高级语言，三种语言的特点" class="headerlink" title="计算机语言：机器语言、汇编语言、高级语言，三种语言的特点"></a>计算机语言：机器语言、汇编语言、高级语言，三种语言的特点</h1><ol><li>机器语言是用二进制代码表示的计算机能直接识别和执行的一种机器指令的集合。</li><li>汇编语言是一种用助记符表示的仍然面向机器的计算机语言。</li><li>高级语言是与自然语言相近并为计算机所接受和执行的计算机语言。</li></ol><h1 id="计算机系统的构成：硬件系统和软件系统"><a href="#计算机系统的构成：硬件系统和软件系统" class="headerlink" title="计算机系统的构成：硬件系统和软件系统"></a>计算机系统的构成：硬件系统和软件系统</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;冯•诺依曼结构计算机的特点&quot;&gt;&lt;a href=&quot;#冯•诺依曼结构计算机的特点&quot; class=&quot;headerlink&quot; title=&quot;冯•诺依曼结构计算机的特点&quot;&gt;&lt;/a&gt;冯•诺依曼结构计算机的特点&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;计算机由运算器、控制器、存储器、输入设备
      
    
    </summary>
    
      <category term="计算机组成原理" scheme="http://sunlanchang.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="计算机组成原理" scheme="http://sunlanchang.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>数据定义</title>
    <link href="http://sunlanchang.github.io/2017/11/27/%E6%95%B0%E6%8D%AE%E5%AE%9A%E4%B9%89/"/>
    <id>http://sunlanchang.github.io/2017/11/27/数据定义/</id>
    <published>2017-11-27T07:42:36.000Z</published>
    <updated>2017-11-27T07:46:27.560Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>SQL功能分为一下四大部分：</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h1&gt;&lt;p&gt;SQL功能分为一下四大部分：&lt;/p&gt;

      
    
    </summary>
    
      <category term="数据库原理与应用" scheme="http://sunlanchang.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8/"/>
    
    
      <category term="数据库原理与应用" scheme="http://sunlanchang.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>图解寻址方式</title>
    <link href="http://sunlanchang.github.io/2017/11/21/%E5%9B%BE%E8%A7%A3%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F/"/>
    <id>http://sunlanchang.github.io/2017/11/21/图解寻址方式/</id>
    <published>2017-11-21T14:56:44.000Z</published>
    <updated>2017-11-22T02:38:25.708Z</updated>
    
    <content type="html"><![CDATA[<h1 id="直接寻址"><a href="#直接寻址" class="headerlink" title="直接寻址"></a>直接寻址</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/zhijiexunzhi.gif" alt="直接寻址" title="">                </div>                <div class="image-caption">直接寻址</div>            </figure>  <h1 id="间接寻址"><a href="#间接寻址" class="headerlink" title="间接寻址"></a>间接寻址</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/jianjiexunzhi.png" alt="存储器间接寻址" title="">                </div>                <div class="image-caption">存储器间接寻址</div>            </figure>  <figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/jicunqijianjiexunzhi.jpg" alt="寄存器间接寻址" title="">                </div>                <div class="image-caption">寄存器间接寻址</div>            </figure><h1 id="基址寻址"><a href="#基址寻址" class="headerlink" title="基址寻址"></a>基址寻址</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/jizhixunzhi.jpg" alt="基址寻址" title="">                </div>                <div class="image-caption">基址寻址</div>            </figure><h1 id="变址寻址"><a href="#变址寻址" class="headerlink" title="变址寻址"></a>变址寻址</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/bianzhixunzhi.jpg" alt="变址寻址" title="">                </div>                <div class="image-caption">变址寻址</div>            </figure><h1 id="立即数寻址"><a href="#立即数寻址" class="headerlink" title="立即数寻址"></a>立即数寻址</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/lijixunzhi.jpg" alt="立即数寻址" title="">                </div>                <div class="image-caption">立即数寻址</div>            </figure><h1 id="寄存器寻址"><a href="#寄存器寻址" class="headerlink" title="寄存器寻址"></a>寄存器寻址</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/jicunqixunzhi.jpg" alt="寄存器寻址" title="">                </div>                <div class="image-caption">寄存器寻址</div>            </figure><h1 id="相对寻址"><a href="#相对寻址" class="headerlink" title="相对寻址"></a>相对寻址</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/xiangduixunzhi.png" alt="相对寻址" title="">                </div>                <div class="image-caption">相对寻址</div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;直接寻址&quot;&gt;&lt;a href=&quot;#直接寻址&quot; class=&quot;headerlink&quot; title=&quot;直接寻址&quot;&gt;&lt;/a&gt;直接寻址&lt;/h1&gt;&lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lig
      
    
    </summary>
    
      <category term="计算机组成原理" scheme="http://sunlanchang.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="计算机组成原理" scheme="http://sunlanchang.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>数据查询</title>
    <link href="http://sunlanchang.github.io/2017/11/19/%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2/"/>
    <id>http://sunlanchang.github.io/2017/11/19/数据查询/</id>
    <published>2017-11-19T14:47:38.000Z</published>
    <updated>2017-11-27T07:42:09.689Z</updated>
    
    <content type="html"><![CDATA[<p>数据查询功能查询功能是SQL按的核心功能，是数据库用的最多的操作，查询语句是SQL语句比较复杂的语句。以下查询用到的三张表如下所示：<br><strong>Student表：</strong>  </p><table><thead><tr><th>Sno</th><th>Sname</th><th>Ssex</th><th>Sage</th><th>Sdept</th></tr></thead><tbody><tr><td>150752</td><td>孙兰昌</td><td>男</td><td>20</td><td>计算机系</td></tr><tr><td>150765</td><td>梁诗笛</td><td>女</td><td>19</td><td>计算机系</td></tr><tr><td>…</td><td>…</td><td>…</td><td>…</td><td>…</td></tr></tbody></table><p><strong>Course表：</strong>  </p><table><thead><tr><th style="text-align:center">Cno</th><th style="text-align:center">Cname</th><th style="text-align:center">Credit</th><th style="text-align:center">Semester</th></tr></thead><tbody><tr><td style="text-align:center">c01</td><td style="text-align:center">高等数学</td><td style="text-align:center">5</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">c02</td><td style="text-align:center">数据结构</td><td style="text-align:center">3</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">…</td><td style="text-align:center">…</td><td style="text-align:center">…</td><td style="text-align:center">…</td></tr></tbody></table><p><strong>SC表：</strong>  </p><table><thead><tr><th style="text-align:center">Sno</th><th style="text-align:center">Cno</th><th style="text-align:center">Grade</th></tr></thead><tbody><tr><td style="text-align:center">150752</td><td style="text-align:center">c01</td><td style="text-align:center">90</td></tr><tr><td style="text-align:center">150765</td><td style="text-align:center">c02</td><td style="text-align:center">88</td></tr><tr><td style="text-align:center">…</td><td style="text-align:center">…</td><td style="text-align:center">…</td></tr></tbody></table><h1 id="查询语句的基本结构"><a href="#查询语句的基本结构" class="headerlink" title="查询语句的基本结构"></a>查询语句的基本结构</h1><p>查询语句的基本结构可描述为：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> &lt;目标列名序列&gt;      <span class="comment">--需要哪些列</span></div><div class="line">  <span class="keyword">from</span> &lt;数据源&gt;           <span class="comment">--来自哪些表</span></div><div class="line">  [<span class="keyword">where</span> &lt;检索条件表达式&gt;] <span class="comment">--根据什么条件</span></div><div class="line">  [<span class="keyword">group</span> <span class="keyword">by</span> &lt;分组依据列&gt;]</div><div class="line">  [<span class="keyword">having</span> &lt;组提取条件&gt;]</div><div class="line">  [<span class="keyword">order</span> <span class="keyword">by</span> &lt;排序依旧列&gt;]</div></pre></td></tr></table></figure></p><h1 id="单表查询"><a href="#单表查询" class="headerlink" title="单表查询"></a>单表查询</h1><h2 id="distinct去重"><a href="#distinct去重" class="headerlink" title="distinct去重"></a><code>distinct</code>去重</h2><p>SQL语言中的<code>distinct</code>关键字可以去掉查询结果的重复行，<code>distinct</code>放在<code>select</code>的后边、目标列名的前边。例如：<br><code>select distinct Sno from SC</code></p><h2 id="not-in、-匹配、escape转义、order-by排序"><a href="#not-in、-匹配、escape转义、order-by排序" class="headerlink" title="[not] in、_%[]匹配、escape转义、order by排序"></a><code>[not] in</code>、<code>_%[]</code>匹配、<code>escape</code>转义、<code>order by</code>排序</h2><ol><li><strong>in确定集合</strong><br><code>in</code>确定某个集合，<code>not in</code>不在某个集合，例如：   <ul><li><code>select Sname, Ssex from Student  where Sdept in (&#39;计算机系&#39;, &#39;数学系&#39;)</code>此查询等价于  <code>select Sname, Ssex from Student where Sdept=&#39;计算机系&#39; or Sdept=&#39;数学系&#39;</code>  </li><li><code>select Sname, Ssex from Student where Sdept not in (&#39;计算机系&#39;, &#39;数学系&#39;)</code>此查询等价于  <code>select Sname, Ssex from Student where Sdept!=&#39;计算机系&#39; and Sdept!=&#39;数学系&#39;</code>  </li></ul></li><li><strong>字符串匹配</strong><br>一般形式为：<code>列名 [not] like &lt;匹配串&gt;</code><ol><li><code>_</code>：匹配任意一个字符</li><li><code>%</code>：匹配0个或多个字符</li><li><code>[]</code>：匹配<code>[]</code>中的任意一个字符。如<code>[aeiou]</code>匹配a、e、i、o、u中的任何一个。对于连续的字母匹配，例如<code>[abcd]</code>可以简写<code>[a-d]</code>。  </li><li><code>[^]</code>：不匹配[]中的任何一个字符。如<code>[^abc]</code>表示不匹配a、b、c。对于连续的字母可以简写例如<code>[^a-d]</code>。</li></ol></li><li><strong>escape转义字符匹配</strong><br>语法格式：<code>escape 转义字符</code><br>例如：  <code>where field like &#39;%30\%%&#39; escape &#39;\&#39;</code></li><li><strong>对查询结果进行排序</strong><br>排序语法格式： <code>order by &lt;列名&gt; [asc | desc]</code><br><code>asc</code>：升序排序，<code>desc</code>：降序排序。如果指定多个列排序，则按照列的先后顺序排序，即最前面的优先级最高。</li><li><strong>使用聚合函数汇总数据</strong><ul><li><code>count([distinct] &lt;列名&gt;)</code>：统计本列非空列值个数。</li><li><code>sum()  ave()  min()  max()</code>功能类似  </li></ul></li></ol><h2 id="group-by分组"><a href="#group-by分组" class="headerlink" title="group by分组"></a>group by分组</h2><p>语法：<code>group by [分组依据列] [having &lt;组约束条件&gt;]</code><br>SQL先执行<code>where</code>后执行<code>group by</code>再执行<code>having</code>，建议在所有分组之前进行的搜索条件放在<code>where</code>中，分组之后的条件搜索放在<code>having</code>中更为高效。<br><strong>Note：</strong><br>查询年龄小于20学生人数：<code>select Sdept, count(*) from Student where age &lt; 20 group by Sdept</code>，而不能写成：<code>select Sdept, count(*) from Student group by Sdept having Sage &lt; 20</code>，因为在分组之后只保留分组依据列以及聚合函数，因为执行到<code>having</code>时已经没有<code>Sage</code>列了。</p><h1 id="多表连接查询"><a href="#多表连接查询" class="headerlink" title="多表连接查询"></a>多表连接查询</h1><h2 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h2><p>使用内连接时，如果两个表的相关字段满足连接条件，则从两个表提取数据并组合成新的记录。<br>语法格式：<code>from table1 [inner] join table on &lt;连接条件&gt;</code><br>例如：<code>select * from studnet inner join SC on Studnet.Sno = SC.Sno</code></p><h2 id="自连接"><a href="#自连接" class="headerlink" title="自连接"></a>自连接</h2><p>在自连接时一定要有别名。<br>例如：查询与操作系统学分相同的课程的课程名和学分。<code>select C1.Cname, C2.Credit from Course C1 join Course C2 on C1.Credit = C2.Credit where C2.Cname = &#39;操作系统&#39;</code></p><h2 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h2><p>查找不满足条件的记录。<code>left</code>以左表为基础对右表进行筛选，<code>right</code>类似。<br>语法：<code>from table1 left | right [outer] join table2 on &lt;连接条件&gt;</code><br>例如：查询学生的选课情况，包括选了课程的学生和没有选课程的学生，列出学号、姓名、课程号和成绩。<code>select Studnet.Sno, Sname, Cno, Grade from Student left outer join SC on Student.Sno = SC.Sno</code></p><h1 id="使用TOP限制结果集"><a href="#使用TOP限制结果集" class="headerlink" title="使用TOP限制结果集"></a>使用TOP限制结果集</h1><p>语法：<code>top n [percent] [with ties]</code><br>一般与<code>order by</code>同时使用。<br>其中：  </p><ul><li>n为非负整数</li><li><code>top n</code>表示取查询的前n行数据</li><li><code>top n percent</code>：表示取查询结果的前n%行数据</li><li><code>with ties</code>：包括并列的结果<br>例如：查询年龄最大的三个学生的信息,包括并列的情况。<code>select top 3 with ties * from Student order by Sage desc</code><h1 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h1>SQL语言中，一个<code>select-from-where</code>语句称为一个查询块。一个查询块嵌入了另外一个<code>select</code>、<code>insert</code>、<code>update</code>或<code>delete</code>则称为子查询或内层查询。  <h2 id="集合测试"><a href="#集合测试" class="headerlink" title="集合测试"></a>集合测试</h2>语法：<code>where 表达式 [not] in (子查询)</code><br>例如：  </li></ul><ol><li>查询与小明同在一个系学习的学生。<code>select * from Student where Sdept in (select Sdept from Student where Sname=&#39;小明&#39;)</code>  </li><li>查询选了c02课程的学生。<code>select * from Student where Sno in (select Sno from SC where Cno=&#39;c02&#39;) and</code>，此查询也可以用多表连接查询实现：<code>select * from Student as S join SC on S.Sno==SC.Sno where Sdept=&#39;计算机系&#39; and Cno=&#39;c02&#39;</code>  <h2 id="比较测试"><a href="#比较测试" class="headerlink" title="比较测试"></a>比较测试</h2>语法：<code>where 表达式 比较运算符 (子查询)</code><br>其中比较运算符有：<code>= &lt;&gt; &lt; &gt; &lt;= &gt;=</code>。<br>例如：  </li></ol><ul><li>查询考试成绩高于平均成绩的学生：<code>select * from student from SC group by Sno having AVG(Grade) &gt; (select AVG(Grade) from SC)</code>。<blockquote><p>集合测试和比较测试都是先执行子查询，在执行外层查询，子查询只执行一次且不依赖于外层查询，这样的查询称为<strong>不相关子查询</strong>或<strong>嵌套子查询</strong>。  </p></blockquote></li></ul><h2 id="存在测试"><a href="#存在测试" class="headerlink" title="存在测试"></a>存在测试</h2><p>语法：<code>where [not] exists (子查询)</code>  </p><ol><li>存在测试先执行外层查询，后执行子查询；子层查询的次数由外层查询结果决定。</li><li>存在测试只返回真值或假值，所以在子查询中指定列名没有意义，通常用<code>select *</code>代替。<br>例如：查询选修了c01课程的学生：<code>select * from Student where exists (select * from SC where Sno = Student.Sno and Cno = &#39;c01&#39;)</code>  </li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;数据查询功能查询功能是SQL按的核心功能，是数据库用的最多的操作，查询语句是SQL语句比较复杂的语句。以下查询用到的三张表如下所示：&lt;br&gt;&lt;strong&gt;Student表：&lt;/strong&gt;  &lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Sno&lt;/th&gt;

      
    
    </summary>
    
      <category term="数据库原理与应用" scheme="http://sunlanchang.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8/"/>
    
    
      <category term="数据库原理与应用" scheme="http://sunlanchang.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>寻址方式之——相对寻址、堆栈寻址</title>
    <link href="http://sunlanchang.github.io/2017/11/18/%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%E4%B9%8B%E2%80%94%E2%80%94%E7%9B%B8%E5%AF%B9%E5%AF%BB%E5%9D%80%E3%80%81%E5%A0%86%E6%A0%88%E5%AF%BB%E5%9D%80/"/>
    <id>http://sunlanchang.github.io/2017/11/18/寻址方式之——相对寻址、堆栈寻址/</id>
    <published>2017-11-18T15:28:21.000Z</published>
    <updated>2017-11-22T02:38:17.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="相对寻址"><a href="#相对寻址" class="headerlink" title="相对寻址"></a>相对寻址</h1><ul><li>与基址变址寻址方式相类似，相对寻址以程序计数器PC的当前值（R15中的值）为基地址，指令中的地址标号作为偏移量，将两者相加后得到操作数的有效地址。</li><li>相对寻址主要用于转移指令，执行本条命令后，转移到（PC）+ Disp，（PC）为程序计数器的内容。</li><li>特点：  <ol><li>转移地址不是固定的，它随着PC值的变化而变化，并且总是与PC相差一个固定的值disp，因此无论程序转入存储器的任何地方，均能正确运行，对浮动程序很适用。</li><li>位移量可正、可负，通常用补码表示。<br><img src="/images/xiangduixunzhi.png" alt="相对寻址"><h1 id="堆栈寻址"><a href="#堆栈寻址" class="headerlink" title="堆栈寻址"></a>堆栈寻址</h1>堆栈是一种数据结构，按先进后出（First In Last Out，FILO）的方式工作，使用堆栈指针（Stack Pointer, SP）指示当前的操作位置，堆栈指针总是指向栈顶。<br>根据堆栈的生成方式不同，可以把堆栈分为递增堆栈和递减堆栈两种类型。</li></ol></li></ul><ul><li>递增堆栈：向堆栈写入数据时，堆栈由低地址向高地址生长。</li><li>递减堆栈：向堆栈写入数据时，堆栈由高地址向低地址生长。<br>同时，根据堆栈指针（SP）指向的位置，又可以把堆栈分为满堆栈（Full Stack）和空堆栈（Empty Stack）两种类型。</li><li>满堆栈（Full Stack）：堆栈指针指向最后压入堆栈的数据。满堆栈在向堆栈存放数据时的操作是先移动SP指针，然后存放数据。在从堆栈取数据时，先取出数据，随后移动SP指针。这样保证了SP一直指向有效的数据。</li><li>空堆栈（Empty Stack）：堆栈指针SP指向下一个将要放入数据的空位置。空堆栈在向堆栈存放数据时的操作是先放数据，然后移动SP指针。在从堆栈取数据时，是先移动指针，再取数据。这种操作方式保证了堆栈指针一直指向一个空地址（没有有效数据的地址）。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;相对寻址&quot;&gt;&lt;a href=&quot;#相对寻址&quot; class=&quot;headerlink&quot; title=&quot;相对寻址&quot;&gt;&lt;/a&gt;相对寻址&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;与基址变址寻址方式相类似，相对寻址以程序计数器PC的当前值（R15中的值）为基地址，指令中的地址标号作为偏移量，
      
    
    </summary>
    
      <category term="计算机组成原理" scheme="http://sunlanchang.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="计算机组成原理" scheme="http://sunlanchang.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>寻址方式之——基址寻址、变址寻址</title>
    <link href="http://sunlanchang.github.io/2017/11/17/%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%E4%B9%8B%E2%80%94%E2%80%94%E5%9F%BA%E5%9D%80%E5%AF%BB%E5%9D%80%E3%80%81%E5%8F%98%E5%9D%80%E5%AF%BB%E5%9D%80/"/>
    <id>http://sunlanchang.github.io/2017/11/17/寻址方式之——基址寻址、变址寻址/</id>
    <published>2017-11-17T15:17:59.000Z</published>
    <updated>2017-11-22T02:37:12.496Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基址寻址"><a href="#基址寻址" class="headerlink" title="基址寻址"></a>基址寻址</h1><ol><li>在计算机设置一个专用的基址寄存器，或者由指令指定一个通用寄存器为基址寄存器。操作数的地址由基址寄存器的内容和指令的地址码A相加得到，这种情况下地址码A常被成为位移量（disp）。</li><li>当存储器容量比较大，有指令的地址码部分直接给出的地址不能直接访问到存储器的单元时，通常将存储器分成若干段，段的首地址存放在基址寄存器中，段内的位移量由指令给出。存储器的实际地址就等于基址寄存器和段内位移量相加。</li><li>基址寻址主要用来解决程序在存储器中的定位和扩大寻址空间等问题。通常基址寄存器只能由系统程序设定，由特权指令执行，一般用户不能够修改，保证了系统的安全性。<br><img src="/images/jizhixunzhi.jpg" alt="基址寻址"><h1 id="变址寻址"><a href="#变址寻址" class="headerlink" title="变址寻址"></a>变址寻址</h1>指令地址码给出地址A和指定的变址寄存器R,将A和R的内容相加就是操作数的地址。常利用变址操作与循环执行程序的方法对数组进行运算。<br><img src="/images/bianzhixunzhi.jpg" alt="变址寻址"><h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1></li></ol><ul><li>基址寻址主要用于为程序或数据分配存储空间，故基址寄存器的内容通常由操作系统或管理程序确定，在程序运行过程中，值是不可变的，而指令字中的地址码是可变的。</li><li>变址寻址中，变址寄存器的内容是用户自己设定的，在程序运行过程中是可变的，而指令字中的地址码是不可变的。编制寻址主要用于处理数组等问题，并且特别适合编制循环程序。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基址寻址&quot;&gt;&lt;a href=&quot;#基址寻址&quot; class=&quot;headerlink&quot; title=&quot;基址寻址&quot;&gt;&lt;/a&gt;基址寻址&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;在计算机设置一个专用的基址寄存器，或者由指令指定一个通用寄存器为基址寄存器。操作数的地址由基址寄存器的内容和指令
      
    
    </summary>
    
      <category term="计算机组成原理" scheme="http://sunlanchang.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="计算机组成原理" scheme="http://sunlanchang.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>寻址方式之——直接寻址、间接寻址</title>
    <link href="http://sunlanchang.github.io/2017/11/17/%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%E4%B9%8B%E2%80%94%E2%80%94%E7%9B%B4%E6%8E%A5%E5%AF%BB%E5%9D%80%E3%80%81%E9%97%B4%E6%8E%A5%E5%AF%BB%E5%9D%80/"/>
    <id>http://sunlanchang.github.io/2017/11/17/寻址方式之——直接寻址、间接寻址/</id>
    <published>2017-11-17T14:31:12.000Z</published>
    <updated>2017-11-22T02:37:55.588Z</updated>
    
    <content type="html"><![CDATA[<h1 id="直接寻址"><a href="#直接寻址" class="headerlink" title="直接寻址"></a>直接寻址</h1><p>指令的地址码部分给出操作数在存储器中的地址，比如给出一个操作数的字段为3位，则寻址方式为有8种。如下图<br><img src="/images/zhijiexunzhi.gif" alt="直接寻址"><br>注意：立即寻址方式和直接寻址方式的书写格式的不同，直接寻址的地址要写在括号“[”，“]”内。在程序中，直接地址通常用内存变量名来表示，如：MOV BX, VARW，其中，VARW是内存字变量。<br>试比较下列指令中源操作数的寻址方式(VARW是内存字变量)：<br><figure class="highlight arm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">MOV　</span>AX, <span class="number">1234</span>H<span class="comment">;    MOV　AX, [1234H] ;前者是立即寻址，后者是直接寻址</span></div><div class="line"><span class="keyword">MOV　</span>AX, VARW<span class="comment">;     MOV　AX, [VARW] ;两者是等效的，均为直接寻址</span></div></pre></td></tr></table></figure></p><h1 id="间接寻址"><a href="#间接寻址" class="headerlink" title="间接寻址"></a>间接寻址</h1><p>在寻址是，有时根据指令的地址码所取出的内容既不是操作数，也不是下一条要执行的指令，而是操作数的地址或指令的地址，这种方式成为间接寻址。根据地址码指的是寄存器地址还是存储器地址，间接寻址又可以分为寄存器间接寻址和存储器间接寻址两种方式。间接寻址有一次间接寻址和间接寻址两种情况，大多数计算机只允许一次间接寻址。对于存储器一次间接寻址情况，许访问两次存储器才能取得数据，第一次从存储器读出操作数地址，第二次读出操作数。如下图所示<br><img src="/images/jianjiexunzhi.png" alt="存储器间接寻址"><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/jicunqijianjiexunzhi.jpg" alt="寄存器间接寻址" title="">                </div>                <div class="image-caption">寄存器间接寻址</div>            </figure>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;直接寻址&quot;&gt;&lt;a href=&quot;#直接寻址&quot; class=&quot;headerlink&quot; title=&quot;直接寻址&quot;&gt;&lt;/a&gt;直接寻址&lt;/h1&gt;&lt;p&gt;指令的地址码部分给出操作数在存储器中的地址，比如给出一个操作数的字段为3位，则寻址方式为有8种。如下图&lt;br&gt;&lt;img sr
      
    
    </summary>
    
      <category term="计算机组成原理" scheme="http://sunlanchang.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="计算机组成原理" scheme="http://sunlanchang.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>IP地址、IP子网、CIDR</title>
    <link href="http://sunlanchang.github.io/2017/11/14/IP%E5%9C%B0%E5%9D%80%E3%80%81IP%E5%AD%90%E7%BD%91%E3%80%81CIDR/"/>
    <id>http://sunlanchang.github.io/2017/11/14/IP地址、IP子网、CIDR/</id>
    <published>2017-11-14T14:11:22.000Z</published>
    <updated>2017-11-17T14:23:16.102Z</updated>
    
    <content type="html"><![CDATA[<h1 id="标准分类的IP地址"><a href="#标准分类的IP地址" class="headerlink" title="标准分类的IP地址"></a>标准分类的IP地址</h1><p>先来一张图便于查阅，如下图：<br><img src="/images/biaozhunfenleiIPdizhi.png" alt="标准分类的IP地址"><br>在互联网络中，需要为每个主机和路由器等设备分配一个在全世界范围内唯一的IP地址，格式为<code>{&lt;网络号&gt;，&lt;主机号&gt;}</code>IP地址的编址方法共经历了以下五个阶段：</p><ol><li>分类的IP地址。  </li><li>划分子网。  </li><li>构成超网。</li><li>网络地址转换。</li><li>IPv6。<br>如下图所示：<br><img src="/images/IPyanbianguocheng.png" alt="">  <h1 id="IP子网的划分"><a href="#IP子网的划分" class="headerlink" title="IP子网的划分"></a>IP子网的划分</h1>格式为：<code>{&lt;网络号&gt;，&lt;子网号&gt;，&lt;主机号&gt;}</code></li></ol><ul><li>A类地址的默认子网掩码：255.0.0.0  </li><li>B类地址的默认子网掩码：255.255.0.0  </li><li>C类地址的默认子网掩码：255.255.255.0<br><img src="/images/ziwangyanma.png" alt=""><br><strong>例如一个B类IP为202.194.0.0均分给6个部门使用，求子网掩码、网络号、子网号、主机号？</strong>  </li></ul><ol><li>从<code>202.194.0.0</code>这个地址可以知道（网络号是<code>202.194</code>，则主机号是16位）</li><li>因为2的3次方为8，所以需要从主机号借3位作子网号才能保证分出6子网，剩下的13位作为主机号，每个子网可容纳最大主机数213 - 2 = 8190个，减去网络地址和广播地址。</li><li><p>子网号和主机号  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">202.194.0.0（子网号000）202.194.0.1~202.194.0.254（主机号）202.194.0.255（广播地址）</div><div class="line">202.194.32.0（子网号001）202.194.32.1~202.194.32.254（主机号）202.194.32.255（广播地址）</div><div class="line">202.194.64.0（子网号010）202.194.64.1~202.194.64.254（主机号）202.194.64.255（广播地址）</div><div class="line">202.194.96.0（子网号011）202.194.96.1~202.194.96.254（主机号）202.194.96.255（广播地址）</div><div class="line">202.194.128.0（子网号100）202.194.128.1~202.194.128.254（主机号）202.194.128.255（广播地址）</div><div class="line">202.194.160.0（子网号101）202.194.160.1~202.194.160.254（主机号）202.194.160.255（广播地址）</div><div class="line">202.194.192.0（子网号110）202.194.192.1~202.194.192.254（主机号）202.194.192.255（广播地址）</div><div class="line">202.194.224.0（子网号111）202.194.224.1~202.194.224.254（主机号）202.194.224.255（广播地址）</div></pre></td></tr></table></figure></li><li><p>主机号借了3位，子网掩码为<code>11111111.11111111.11100000.00000000</code>即<code>255.255.224.0</code></p><h1 id="3-无分类编址CIDR"><a href="#3-无分类编址CIDR" class="headerlink" title="3.无分类编址CIDR"></a>3.无分类编址CIDR</h1><p>格式为：<code>{&lt;网络前缀&gt;，&lt;主机号&gt;}</code><br>CIDR最主要有两个以下特点：  </p></li></ol><ul><li>消除传统的A，B，C地址和划分子网的概念，更有效的分配IPv4的地址空间，CIDR使IP地址又回到无分类的两级编码。记法：IP地址：：={&lt;&lt;网络前缀&gt;，&lt;&lt;主机号&gt;}。  </li><li>CIDR还使用“斜线记法”即在IP地址后面加上“/”然后写网络前缀所占的位数。CIDR把网络前缀都相同的连续IP地址组成一个“CIDR地址块”，即强化路由聚合（构成超网）。<br><strong>例如<code>202.194.20.138/19</code>，此IP中前19位为网络前缀，后13位为主机号。</strong>  </li></ul><ol><li><code>202.194.20.138/19</code>用二进制表示为：<br><code>11001010  11000010  00010100  1000101</code></li><li>该地址所在CIDR地址块中最小的地址为<br><code>11001010  11000010  00000000  00000000</code>，即<code>202.194.0.0</code></li><li>该地址所在CIDR地址块中最大的地址为：<br><code>11001010  11000010  00011111  11111111</code>，即<code>202.194.31.255</code></li><li>该地址块中共有213=8192个地址</li><li><code>/19</code>对应的子网掩码为<code>11111111.11111111.11100000.00000000</code>，即<code>255.255.224.0</code></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;标准分类的IP地址&quot;&gt;&lt;a href=&quot;#标准分类的IP地址&quot; class=&quot;headerlink&quot; title=&quot;标准分类的IP地址&quot;&gt;&lt;/a&gt;标准分类的IP地址&lt;/h1&gt;&lt;p&gt;先来一张图便于查阅，如下图：&lt;br&gt;&lt;img src=&quot;/images/biaozh
      
    
    </summary>
    
      <category term="计算机网络" scheme="http://sunlanchang.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="http://sunlanchang.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>寻址方式之——立即数寻址、寄存器寻址</title>
    <link href="http://sunlanchang.github.io/2017/11/14/%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%E2%80%94%E2%80%94%E7%AB%8B%E5%8D%B3%E6%95%B0%E5%AF%BB%E5%9D%80%E3%80%81%E5%AF%84%E5%AD%98%E5%99%A8%E5%AF%BB%E5%9D%80/"/>
    <id>http://sunlanchang.github.io/2017/11/14/寻址方式——立即数寻址、寄存器寻址/</id>
    <published>2017-11-14T08:55:18.000Z</published>
    <updated>2017-11-22T02:35:50.731Z</updated>
    
    <content type="html"><![CDATA[<h1 id="立即数寻址"><a href="#立即数寻址" class="headerlink" title="立即数寻址"></a>立即数寻址</h1><p>所需的操作数由指令直接给出，就称为立即数（或直接数）寻址方式。这种方式的特点是：取指令时，操作码和操作数同时被取出，减少了访存次数，提高了指令的执行速度。但是由于这一操作数是指令的一部分，不能修改，所以这种方式只能适用操作数固定的情况，并且操作数的位数有限。通常用于给某一寄存器单元赋初值或者提供一个常数，例如C语言里<code>int a = 1</code>，运用到了立即数寻址。<br>立即数可以是8位、16位或32位，该数值紧跟在操作码之后。如果立即数为16位或32位，那么，它将按“高高低低”的原则进行存储。例如：<br><figure class="highlight arm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">MOV </span>AH, <span class="number">80</span>H</div><div class="line"><span class="keyword">ADD </span>AX, <span class="number">1234</span>H</div><div class="line"><span class="keyword">MOV </span>ECX, <span class="number">123456</span>H</div></pre></td></tr></table></figure></p><p>以上指令中的第二操作数都是立即数，在汇编语言中规定：立即数不能作为指令中的第一操作数，该规定与高级语言中“赋值语句的左边不能是常量”的规定相一致。<br>立即数寻址方式通常用于对通用寄存器或内存单元赋初值。图是指令”MOV AX, 4576H”存储形式和执行示意图。将<code>4576H</code>数据送入<code>AX</code>通用寄存器，类似于赋值语句。<br><img src="/images/lijixunzhi.jpg" alt="立即数寻址"></p><h1 id="寄存器寻址"><a href="#寄存器寻址" class="headerlink" title="寄存器寻址"></a>寄存器寻址</h1><p>计算机的中央处理器一般设置有一定数量的通用寄存器，用来存放操作数，操作数的地址或中间结果。假如指令地址码部分给出某一通用寄存器地址即给出地址码<code>A</code>，而且所需的操作数就在这一寄存器中，则称为寄存器寻址。通用寄存器数量一般在几个到几十个之间，例如x86架构CPU有4个数据寄存器(<code>EAX</code>、<code>EBX</code>、<code>ECX</code>和<code>EDX</code>)，MIPS架构CPU有32个通用寄存器（<code>$0</code>-<code>$31</code>），ARM架构CPU有16个32位的寄存器（<code>r0</code>-<code>r15</code>）。从寄存器中存取数据比从存储器中存取数据快得多，所以这种寻址方式可以缩短指令长度，节省存储空间，提高指令的执行速度。<br><img src="/images/jicunqixunzhi.jpg" alt="寄存器寻址"></p><h2 id="速度的比较"><a href="#速度的比较" class="headerlink" title="速度的比较"></a>速度的比较</h2><p>按照离CPU由近到远的顺序依次是CPU寄存器、Cache、内存、硬盘，越靠近CPU的存储器容量越小但访问速度越快，下图给出了各种存储器的容量和访问速度的典型值。<br><img src="/images/sudubijiao.png" alt="存储器存取数据比较"><br><strong>参考：</strong></p><blockquote><p><a href="http://blog.csdn.net/zlzlei/article/details/7790363" target="_blank" rel="external">http://blog.csdn.net/zlzlei/article/details/7790363</a><br><a href="http://blog.csdn.net/huangxb_csu/article/details/5976561" target="_blank" rel="external">http://blog.csdn.net/huangxb_csu/article/details/5976561</a><br><a href="http://blog.csdn.net/gujing001/article/details/8476685" target="_blank" rel="external">http://blog.csdn.net/gujing001/article/details/8476685</a><br><a href="http://www.cnblogs.com/onroad/archive/2009/07/13/1522673.html" target="_blank" rel="external">http://www.cnblogs.com/onroad/archive/2009/07/13/1522673.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;立即数寻址&quot;&gt;&lt;a href=&quot;#立即数寻址&quot; class=&quot;headerlink&quot; title=&quot;立即数寻址&quot;&gt;&lt;/a&gt;立即数寻址&lt;/h1&gt;&lt;p&gt;所需的操作数由指令直接给出，就称为立即数（或直接数）寻址方式。这种方式的特点是：取指令时，操作码和操作数同时被取出，
      
    
    </summary>
    
      <category term="计算机组成原理" scheme="http://sunlanchang.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="计算机组成原理" scheme="http://sunlanchang.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu使用蓝灯无限流量</title>
    <link href="http://sunlanchang.github.io/2017/11/03/Ubuntu%E4%BD%BF%E7%94%A8%E8%93%9D%E7%81%AF%E6%97%A0%E9%99%90%E6%B5%81%E9%87%8F/"/>
    <id>http://sunlanchang.github.io/2017/11/03/Ubuntu使用蓝灯无限流量/</id>
    <published>2017-11-03T05:37:10.000Z</published>
    <updated>2017-11-06T01:03:35.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>lantern</code>因为蓝灯3是通过用户的 <code>MAC</code> 地址来判断用户是否使用完免费高速流量。<br>这里修改 <code>MAC</code> 地址的具体步骤如下：</p><ol><li>通过 <code>ifconfig</code> 查看网卡设备，这里是enp2s0，有些地方是 eth0，以下统称 net_card 。</li><li>关闭网卡设备 <code>sudo /sbin/ifconfig net_card down</code></li><li>修改 <code>MAC</code> 地址 <code>sudo /sbin/ifconfig net_card hw ether 00:AA:BB:CC:DD:EE</code> (要修改的<code>MAC</code>地址)</li><li>重新启用网卡 <code>sudo /sbin/ifconfig net_card up</code></li></ol><p>这是临时性修改<code>MAC</code>地址的方法，系统重启之后就会失效。不过这也比较符合我们的需求，一个<code>MAC</code>地址的免费高速流量用完之后就换另一个地址。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;lantern&lt;/code&gt;因为蓝灯3是通过用户的 &lt;code&gt;MAC&lt;/code&gt; 地址来判断用户是否使用完免费高速流量。&lt;br&gt;这里修改 &lt;code&gt;MAC&lt;/code&gt; 地址的具体步骤如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;通过 &lt;code&gt;ifconfig&lt;/
      
    
    </summary>
    
      <category term="Other" scheme="http://sunlanchang.github.io/categories/Other/"/>
    
    
      <category term="Other" scheme="http://sunlanchang.github.io/tags/Other/"/>
    
  </entry>
  
  <entry>
    <title>校园网自动登录脚本</title>
    <link href="http://sunlanchang.github.io/2017/10/31/%E6%A0%A1%E5%9B%AD%E7%BD%91%E8%87%AA%E5%8A%A8%E7%99%BB%E5%BD%95%E8%84%9A%E6%9C%AC/"/>
    <id>http://sunlanchang.github.io/2017/10/31/校园网自动登录脚本/</id>
    <published>2017-10-31T06:39:42.000Z</published>
    <updated>2017-10-31T06:57:30.555Z</updated>
    
    <content type="html"><![CDATA[<h1 id="校园网自动登录脚本"><a href="#校园网自动登录脚本" class="headerlink" title="校园网自动登录脚本"></a>校园网自动登录脚本</h1><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><ul><li><code>python 2.7或python 3.5</code>均可用，脚本外部依赖<code>requests</code>库，请在运行脚本前<code>pip3</code>或者<code>pip</code>安装<code>requests</code>。  </li><li><code>python 2.7</code>运行时务必加上下面一行代码，指定编码为<code>utf8</code>，<code>python3</code>可以忽略。  <h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2></li></ul><ol><li><p>指定编码方式为utf8。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># coding: utf-8</span></div><div class="line"><span class="keyword">import</span> requests</div></pre></td></tr></table></figure></li><li><p>通过<code>Chrome</code>浏览器得知校园网登录地址，注意直接在浏览器输入的地址不一定是发送数据的地址，我学校是下面这个。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">url = <span class="string">'http://210.31.32.126/cgi-bin/do_login'</span></div></pre></td></tr></table></figure></li><li><p>浏览器头信息用来伪装浏览器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span><span class="params">()</span>:</span></div><div class="line">    postdata = &#123;<span class="string">'username'</span>: <span class="string">'你的校园网账号'</span>,</div><div class="line">                <span class="string">'password'</span>: <span class="string">'&#123;TEXT&#125;你的密码'</span>,</div><div class="line">                <span class="string">'drop'</span>: <span class="string">'0'</span>,</div><div class="line">                <span class="string">'type'</span>: <span class="string">'1'</span>,</div><div class="line">                <span class="string">'n'</span>: <span class="string">'100'</span>&#125;</div><div class="line">    headers = &#123;<span class="string">'Accept'</span>: <span class="string">'*/*'</span>,</div><div class="line">               <span class="string">'Accept-Encoding'</span>: <span class="string">'gzip, deflate'</span>,</div><div class="line">               <span class="string">'Accept-Language'</span>: <span class="string">'zh-CN,zh;q=0.8'</span>,</div><div class="line">               <span class="string">'Connection'</span>: <span class="string">'keep-alive'</span>,</div><div class="line">               <span class="string">'Content-Length'</span>: <span class="string">'65'</span>,</div><div class="line">               <span class="string">'Content-Type'</span>: <span class="string">'application/x-www-form-urlencoded'</span>,</div><div class="line">               <span class="string">'Cookie'</span>: <span class="string">'PHPSESSID=a70fr8pfvhhtt329qvb21p7ka6'</span>,</div><div class="line">               <span class="string">'Host'</span>: <span class="string">'210.31.32.126'</span>,</div><div class="line">               <span class="string">'Origin'</span>: <span class="string">'http://210.31.32.126'</span>,</div><div class="line">               <span class="string">'Referer'</span>: <span class="string">'http://210.31.32.126/'</span>,</div><div class="line">               <span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/61.0.3163.91 Safari/537.36'</span>&#125;</div><div class="line">    requests.post(url, data=postdata)</div></pre></td></tr></table></figure></li></ol><h2 id="查看连接的是否是校园网，以及是否连上网"><a href="#查看连接的是否是校园网，以及是否连上网" class="headerlink" title="查看连接的是否是校园网，以及是否连上网"></a>查看连接的是否是校园网，以及是否连上网</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_connect_edu</span><span class="params">()</span>:</span></div><div class="line">    status_code = requests.get(url).status_code</div><div class="line">    <span class="keyword">if</span> status_code == <span class="number">200</span>:</div><div class="line">        <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_connect_web</span><span class="params">()</span>:</span></div><div class="line">    r = requests.get(<span class="string">"http://www.baidu.com"</span>).text</div><div class="line">    <span class="keyword">if</span> r.find(<span class="string">'210.31.32.126'</span>) != <span class="number">-1</span>:</div><div class="line">        <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        <span class="keyword">return</span> <span class="keyword">True</span></div></pre></td></tr></table></figure><h2 id="直到校园网连接上为止"><a href="#直到校园网连接上为止" class="headerlink" title="直到校园网连接上为止"></a>直到校园网连接上为止</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">    <span class="keyword">if</span> is_connect_edu():  <span class="comment"># 是否连接上校园网</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> is_connect_web():  <span class="comment"># 是否连接上外网</span></div><div class="line">            login()</div><div class="line">            <span class="keyword">if</span> requests.get(<span class="string">'http://www.baidu.com'</span>).status_code==<span class="number">200</span>:</div><div class="line">                print(<span class="string">'Already connected Internet'</span>)</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                print(<span class="string">'Not connected Internet'</span>)</div><div class="line">        <span class="keyword">break</span></div></pre></td></tr></table></figure><h2 id="Ubuntu开机自动启动登录"><a href="#Ubuntu开机自动启动登录" class="headerlink" title="Ubuntu开机自动启动登录"></a><code>Ubuntu</code>开机自动启动登录</h2><p><code>root</code>权限修改<code>/etc/rc.local</code>文件在<code>exit 0</code>上一行加上<code>python3 xiaoyuanwang.py</code>即可实现开机启动此脚本</p><h2 id="获取源码"><a href="#获取源码" class="headerlink" title="获取源码"></a>获取源码</h2><p><a href="https://github.com/sunlanchang/blog/blob/master/%E6%A0%A1%E5%9B%AD%E7%BD%91%E8%87%AA%E5%8A%A8%E7%99%BB%E5%BD%95.py" target="_blank" rel="external">点击获取源码</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;校园网自动登录脚本&quot;&gt;&lt;a href=&quot;#校园网自动登录脚本&quot; class=&quot;headerlink&quot; title=&quot;校园网自动登录脚本&quot;&gt;&lt;/a&gt;校园网自动登录脚本&lt;/h1&gt;&lt;h2 id=&quot;环境&quot;&gt;&lt;a href=&quot;#环境&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="小程序" scheme="http://sunlanchang.github.io/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
      <category term="小程序" scheme="http://sunlanchang.github.io/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>极限的保号性、无穷小运算法则、七种未定型</title>
    <link href="http://sunlanchang.github.io/2017/10/31/%E6%9E%81%E9%99%90%E7%9A%84%E4%BF%9D%E5%8F%B7%E6%80%A7%E3%80%81%E6%97%A0%E7%A9%B7%E5%B0%8F%E8%BF%90%E7%AE%97%E6%B3%95%E5%88%99%E3%80%81%E4%B8%83%E7%A7%8D%E6%9C%AA%E5%AE%9A%E5%9E%8B/"/>
    <id>http://sunlanchang.github.io/2017/10/31/极限的保号性、无穷小运算法则、七种未定型/</id>
    <published>2017-10-31T05:46:11.000Z</published>
    <updated>2017-10-31T06:34:02.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="极限的保号性、运算法则、七种未定型"><a href="#极限的保号性、运算法则、七种未定型" class="headerlink" title="极限的保号性、运算法则、七种未定型"></a>极限的保号性、运算法则、七种未定型</h1><h2 id="极限的保号性"><a href="#极限的保号性" class="headerlink" title="极限的保号性"></a>极限的保号性</h2><ol><li>$\lim\limits_{x\to a}f(x)=A(A\neq0)$则$f(x)$与$A$同号。</li><li>$f(x)&gt;0$，$\lim\limits_{x\to a}f(x)=A$则$A\geq0$。<h2 id="无穷小运算"><a href="#无穷小运算" class="headerlink" title="无穷小运算"></a>无穷小运算</h2></li></ol><ul><li>相同的运算法则  </li></ul><ol><li>$o(x^m)\pm o(x^n)=o(x^n)$其中$(m&gt;n)$  </li><li>$x^mo(x^n)=o(x^{m+n})$  </li><li>$\frac{o(x^m)}{o(x^n)}=0$其中$(m&gt;n)$  </li><li>$ko(x^n)=o(x^n)$  </li></ol><ul><li>注意无穷大加减运算与无穷小相反。  </li></ul><ol><li>$o(x^m)\pm o(x^n)=o(x^m)$其中$(m&gt;n)$  <h2 id="七种未定型的极限"><a href="#七种未定型的极限" class="headerlink" title="七种未定型的极限"></a>七种未定型的极限</h2><h3 id="1-第一类：-frac-0-0-，-frac-infty-infty-，-0-cdot-infty"><a href="#1-第一类：-frac-0-0-，-frac-infty-infty-，-0-cdot-infty" class="headerlink" title="1. 第一类：$\frac{0}{0}$，$\frac{\infty}{\infty}$，$0\cdot\infty$"></a>1. 第一类：$\frac{0}{0}$，$\frac{\infty}{\infty}$，$0\cdot\infty$</h3></li><li>洛必达法则</li><li>等价无穷小代换</li><li>泰勒展开式</li><li>消去去穷大（做大题用）</li><li>抓大头（做选择、填空或者检验大题答案用）<h3 id="2-第二类：-infty-0-，-0-0-，-1-1的任意次幂"><a href="#2-第二类：-infty-0-，-0-0-，-1-1的任意次幂" class="headerlink" title="2. 第二类：$\infty^0$，$0^0$，$1^*$(1的任意次幂)"></a>2. 第二类：$\infty^0$，$0^0$，$1^*$(1的任意次幂)</h3></li><li>$1^*$常用${f(x)}^{g(x)}=e^{(f(x)-1)g(x)}$  </li><li>$\infty^0$，$0^0$常用${u(x)}^{v(x)}=e^{v(x)\ln u(x)}$<h3 id="3-第三类：-infty-infty"><a href="#3-第三类：-infty-infty" class="headerlink" title="3. 第三类：$\infty-\infty$"></a>3. 第三类：$\infty-\infty$</h3></li><li>有分母时通分化成前两种情况。</li><li>没有分母倒代换构造分母。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;极限的保号性、运算法则、七种未定型&quot;&gt;&lt;a href=&quot;#极限的保号性、运算法则、七种未定型&quot; class=&quot;headerlink&quot; title=&quot;极限的保号性、运算法则、七种未定型&quot;&gt;&lt;/a&gt;极限的保号性、运算法则、七种未定型&lt;/h1&gt;&lt;h2 id=&quot;极限的保号
      
    
    </summary>
    
      <category term="微积分" scheme="http://sunlanchang.github.io/categories/%E5%BE%AE%E7%A7%AF%E5%88%86/"/>
    
    
      <category term="微积分" scheme="http://sunlanchang.github.io/tags/%E5%BE%AE%E7%A7%AF%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>常用泰勒、微积分公式</title>
    <link href="http://sunlanchang.github.io/2017/10/27/%E5%B8%B8%E7%94%A8%E6%B3%B0%E5%8B%92%E3%80%81%E5%BE%AE%E7%A7%AF%E5%88%86%E5%85%AC%E5%BC%8F%E3%80%81%E5%91%BD%E4%BB%A4/"/>
    <id>http://sunlanchang.github.io/2017/10/27/常用泰勒、微积分公式、命令/</id>
    <published>2017-10-27T04:20:24.000Z</published>
    <updated>2017-10-31T05:54:05.328Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常用公式"><a href="#常用公式" class="headerlink" title="常用公式"></a>常用公式</h1><h2 id="常用穷小替换"><a href="#常用穷小替换" class="headerlink" title="常用穷小替换"></a>常用穷小替换</h2><p>$x=&gt;\sin x=&gt;\tan x=&gt;\arcsin x=&gt;\arctan x=&gt;\ln (x+1)=&gt;e^x-1$<br>$(x+1)^a-1=&gt;ax$<br>$a^x-1=&gt;xln(a)$<br>$1-\cos x=&gt;\frac{1}{2}x^2$<br>$\tan x-\sin x=&gt;\tan x(1-\cos x)=&gt;\frac{1}{2}x^3$  </p><h2 id="常用泰勒展开式"><a href="#常用泰勒展开式" class="headerlink" title="常用泰勒展开式"></a>常用泰勒展开式</h2><ul><li>$x-f(x)$展开<br>$x-\sin x=\frac{1}{6}x^3+o(x^3)$<br>$x-\arcsin x=-\frac{1}{6}x^3+o(x^3)$<br>$x-\tan x=-\frac{1}{3}x^3+o(x^3)$<br>$x-\arctan x=\frac{1}{3}x^3+o(x^3)$</li><li>三角函数展开<br>$e^x=1+x+\frac{x^2}{2!}+\frac{x^3}{3!}+o(x^3)$<br>$\sin x=x-\frac{x^3}{3!}+\frac{x^5}{5!}+o(x^5)$<br>$\cos x=1-\frac{x^2}{2!}+\frac{x^4}{4!}+o(x^4)$<br>$\ln(x+1)=x-\frac{1}{2}x^2+\frac{1}{3}x^3+o(x^3)$<h2 id="常用微分公式"><a href="#常用微分公式" class="headerlink" title="常用微分公式"></a>常用微分公式</h2>$d\tan x=(\sec x)^2dx$<br>$d\cot x=-(\csc x)^2dx$<br>$d\sec x=\sec x\tan xdx$<br>$d\csc x=-\csc x\cot xdx$<br>$d\arcsin x=\frac{1}{\sqrt{1-x^2}}dx$<br>$d\arccos x=-\frac{1}{\sqrt{1-x^2}}dx$<br>$d\arctan x=\frac{1}{1+x^2}dx$<br>$darcot x=-\frac{1}{1+x^2}dx$  <h2 id="常用高阶导数公式"><a href="#常用高阶导数公式" class="headerlink" title="常用高阶导数公式"></a>常用高阶导数公式</h2>$(e^{ax})^{(n)}=a^ne^{an}$<br>$(\sin ax)^{(n)}=a^n\sin (ax+n\frac{\Pi}{2})$<br>$(\cos ax)^{(n)}=a^n\cos (ax+n\frac{\Pi}{2})$<br>$(\ln (1+x))^{(n)}=(-1)^{n-1}\frac{(n-1)!}{(x+1)^n}$<br>$(\frac{1}{x})^{(n)}=(-1)^n\frac{n!}{x^{n+1}}$  </li><li>莱布尼茨公式<br>$(uv)^{(n)}=u^{(n)}v+C_n^1u^{(n-1)}v+C_n^ku^{(n-k)}v^{(k)}+uv^{n}$  <h2 id="常用积分公式"><a href="#常用积分公式" class="headerlink" title="常用积分公式"></a>常用积分公式</h2>$\int \tan xdx=-\ln|\cos x|+C$<br>$\int \cot xdx=\ln|\sin x|+C$<br>$\int \sec xdx=\ln\left|\sec x+\tan x\right|+C$<br>$\int \csc x dx=\ln\left|\csc x-\cot x\right|+C$<br>$\int \sec^2(x)dx=\tan x+C$<br>$\int \csc xdx=\cot x+C$<br>$\int \frac{1}{a^2+x^2}dx=\frac{1}{a}\tan(\frac{1}{a}x)+C$<br>$\int \frac{1}{a^2-x^2}dx=\ln\left|\frac{a+x}{a-x}\right|+C$<br>$\int \frac{1}{\sqrt{a^2-x^2}}dx=\arcsin\frac{1}{a}x$<br>$\int \frac{1}{\sqrt{x^2\pm a^2}}dx=\ln|x+\sqrt{x^2\pm a^2}|+C$<br>$\int \ln xdx=x\ln x-x+C$<h2 id="Mathmatica常用命令"><a href="#Mathmatica常用命令" class="headerlink" title="Mathmatica常用命令"></a>Mathmatica常用命令</h2></li><li><code>Solve[x^2 + a x + 1 == 0, x]</code>求方程的解  </li><li><code>Integrate[f,x,x_min,x_max]</code>求定积分和不定积分  </li><li><code>Limit[Sin[x]/x, x -&gt; 0]</code>求极限  </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;常用公式&quot;&gt;&lt;a href=&quot;#常用公式&quot; class=&quot;headerlink&quot; title=&quot;常用公式&quot;&gt;&lt;/a&gt;常用公式&lt;/h1&gt;&lt;h2 id=&quot;常用穷小替换&quot;&gt;&lt;a href=&quot;#常用穷小替换&quot; class=&quot;headerlink&quot; title=&quot;常用穷小替
      
    
    </summary>
    
      <category term="微积分" scheme="http://sunlanchang.github.io/categories/%E5%BE%AE%E7%A7%AF%E5%88%86/"/>
    
    
      <category term="微积分" scheme="http://sunlanchang.github.io/tags/%E5%BE%AE%E7%A7%AF%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>CRC冗余码</title>
    <link href="http://sunlanchang.github.io/2017/10/26/CRC%E5%86%97%E4%BD%99%E7%A0%81/"/>
    <id>http://sunlanchang.github.io/2017/10/26/CRC冗余码/</id>
    <published>2017-10-26T02:38:07.000Z</published>
    <updated>2017-10-26T03:03:53.383Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CRC校验"><a href="#CRC校验" class="headerlink" title="CRC校验"></a>CRC校验</h1><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>CRC检验原理实际上就是在一个p位二进制数据序列之后附加一个r位二进制检验码(序列)，从而构成一个总长为n＝p＋r位的二进制序列；附加在数据序列之后的这个检验码与数据序列的内容之间存在着某种特定的关系。如果因干扰等原因使数据序列中的某一位或某些位发生错误，这种特定关系就会被破坏。因此，通过检查这一关系，就可以实现对数据正确性的检验。</p><h2 id="几个基本概念"><a href="#几个基本概念" class="headerlink" title="几个基本概念"></a>几个基本概念</h2><ol><li>帧检验序列FCS（Frame Check Sequence）：为了进行差错检验而添加的冗余码。</li><li>多项式模2运行：实际上是按位异或(Exclusive OR)运算，即相同为0，相异为1，也就是不考虑进位、借位的二进制加减运算。如：$10011011 + 11001010 = 01010001$。</li><li>生成多项式（generator polynomial）：当进行CRC检验时，发送方与接收方需要事先约定一个除数，即生成多项式，一般记作$G(x)$。生成多项式的最高位与最低位必须是1。常用的CRC码的生成多项式有：<br>$CRC8=X^8+X^5+X4+1$<br>$CRC-CCITT=X^16+X^12+X^5+1$<br>$CRC16=X^16+X^15+X^5+1$<br>$CRC12=X^12+X^11+X^3+X^2+1$<br>$CRC32=X^32+X^26+X^23+X^22+X^16+X^12+X^11+X^10+X^8+X^7+X^5+X^4+X^2+X^1+1$<br>每一个生成多项式都可以与一个代码相对应，如CRC8对应代码：100110001。<h2 id="CRC检验码的计算"><a href="#CRC检验码的计算" class="headerlink" title="CRC检验码的计算"></a>CRC检验码的计算</h2>设信息字段为K位，校验字段为R位，则码字长度为$N(N=K+R)$。<br>设双方事先约定了一个R次多项式$g(x)$，则CRC码：<br>$V(x)=A(x)g(x)=xRm(x)+r(x)$<br>其中:$m(x)$为K次信息多项式， $r(x)$为$R-1$次校验多项式。<br>这里$r(x)$对应的代码即为冗余码，加在原信息字段后即形成CRC码。<br>r(x)的计算方法为：在K位信息字段的后面添加R个0，再除以$g(x)$对应的代码序列，得到的余数即为$r(x)$对应的代码(应为R－1位；若不足，而在高位补0)。</li></ol><ul><li>计算示例<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/CRC.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>  这里$g(x)=11001$，生成的CRC冗余码为$1010$，最终得到的码字是$1011001010$即<strong>码字 = 被除 + 数冗余码</strong>。<h2 id="错误检测"><a href="#错误检测" class="headerlink" title="错误检测"></a>错误检测</h2>当接收方收到数据后，用收到的数据对P（事先约定的）进行模2除法，若余数为0，则认为数据传输无差错；若余数不为0，则认为数据传输出现了错误，由于不知道错误发生在什么地方，因而不能进行自动纠正，一般的做法是丢弃接收的数据。  </li><li><strong>Note</strong></li></ul><ol><li>CRC是一种常用的检错码，并不能用于自动纠错。</li><li>只要经过严格的挑选，并使用位数足够多的除数 P，那么出现检测不到的差错的概率就很小很小。</li><li>仅用循环冗余检验 CRC 差错检测技术只能做到无差错接受（只是非常近似的认为是无差错的），并不能保证可靠传输。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;CRC校验&quot;&gt;&lt;a href=&quot;#CRC校验&quot; class=&quot;headerlink&quot; title=&quot;CRC校验&quot;&gt;&lt;/a&gt;CRC校验&lt;/h1&gt;&lt;h2 id=&quot;基本原理&quot;&gt;&lt;a href=&quot;#基本原理&quot; class=&quot;headerlink&quot; title=&quot;基本原理&quot;
      
    
    </summary>
    
      <category term="计算机网络" scheme="http://sunlanchang.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="http://sunlanchang.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>利用jieba和wordcloud生成词云</title>
    <link href="http://sunlanchang.github.io/2017/10/26/%E5%88%A9%E7%94%A8jieba%E5%92%8Cwordcloud%E7%94%9F%E6%88%90%E8%AF%8D%E4%BA%91/"/>
    <id>http://sunlanchang.github.io/2017/10/26/利用jieba和wordcloud生成词云/</id>
    <published>2017-10-26T00:20:44.000Z</published>
    <updated>2017-10-26T03:14:31.483Z</updated>
    
    <content type="html"><![CDATA[<h1 id="利用wordcloud和jieba做一个词云"><a href="#利用wordcloud和jieba做一个词云" class="headerlink" title="利用wordcloud和jieba做一个词云"></a>利用<code>wordcloud</code>和<code>jieba</code>做一个词云</h1><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>使用到的轮子：<code>matplotlib</code>，<code>jieba</code>，<code>scipy</code>，<code>wordcloud</code>，<code>numpy</code>，<code>PIL</code>。<br><code>python2</code>对<code>jieba</code>的中文分词支持不是很好，所以使用<code>python3</code>。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">python <span class="number">3.6</span><span class="number">.1</span></div><div class="line">jieba <span class="number">0.39</span></div><div class="line">matplotlib <span class="number">1.0</span><span class="number">.4</span></div><div class="line">scipy <span class="number">1.0</span><span class="number">.0</span></div><div class="line">wordcloud <span class="number">1.3</span><span class="number">.1</span></div><div class="line">numpy <span class="number">1.13</span><span class="number">.3</span></div><div class="line">PIL <span class="number">1.1</span><span class="number">.6</span></div></pre></td></tr></table></figure></p><ul><li><a href="https://github.com/sunlanchang/blog/blob/master/%E5%88%A9%E7%94%A8jieba%E5%92%8Cwordcloud%E7%94%9F%E6%88%90%E8%AF%8D%E4%BA%91.py" target="_blank" rel="external">Github源代码</a><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><h3 id="导入轮子"><a href="#导入轮子" class="headerlink" title="导入轮子"></a>导入轮子</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#encoding=utf-8</span></div><div class="line"><span class="keyword">import</span> jieba</div><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div><div class="line"><span class="keyword">from</span> scipy.misc <span class="keyword">import</span> imread</div><div class="line"><span class="keyword">from</span> wordcloud <span class="keyword">import</span> WordCloud, STOPWORDS, ImageColorGenerator</div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</div></pre></td></tr></table></figure></li></ul><p>所用到的库都能用<code>pip3</code>安装。</p><h3 id="生成分词"><a href="#生成分词" class="headerlink" title="生成分词"></a>生成分词</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">text_from_file=open(<span class="string">'data.txt'</span>,<span class="string">'r'</span>).read()</div><div class="line">Word_spilt_jieba = jieba.cut(text_from_file,cut_all = <span class="keyword">False</span>)</div><div class="line">word_space = <span class="string">' '</span>.join(Word_spilt_jieba)</div></pre></td></tr></table></figure><p>数据是从网上复制了几份十九大，国庆，小说的内容，从文本中读入数据到<code>text</code>，用<code>jieba</code>进行分词，不使用全模式，全模式匹配会出现重复关键词的现象，使用后效果并不好。</p><h3 id="自定义词云背景"><a href="#自定义词云背景" class="headerlink" title="自定义词云背景"></a>自定义词云背景</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">img=imread(<span class="string">'bipt.jpg'</span>)</div><div class="line">img = np.array(Image.open(<span class="string">'bipt.jpg'</span>))</div></pre></td></tr></table></figure><p>设置生成词云的背景，这里用到了numpy将图片转换为矩阵，图片需要自己下载定义背景。</p><h3 id="生成词云"><a href="#生成词云" class="headerlink" title="生成词云"></a>生成词云</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">my_wordcloud = WordCloud(</div><div class="line">    background_color=<span class="string">'white'</span>, <span class="comment">#设置背景颜色</span></div><div class="line">    mask=img,  <span class="comment">#背景图片</span></div><div class="line">    max_words = <span class="number">200</span>, <span class="comment">#设置最大显示的词数</span></div><div class="line">    stopwords = STOPWORDS, <span class="comment">#设置停用词</span></div><div class="line">    <span class="comment">#设置字体格式，字体格式 .ttf文件需自己网上下载，最好将名字改为英文，中文名路径加载会出现问题。</span></div><div class="line">    font_path = <span class="string">'simkai.ttf'</span>, </div><div class="line">    max_font_size = <span class="number">100</span>, <span class="comment">#设置字体最大值</span></div><div class="line">    random_state=<span class="number">50</span>, <span class="comment">#设置随机生成状态，即多少种配色方案</span></div><div class="line">    ).generate(word_space)</div></pre></td></tr></table></figure><p>设置<code>wordcloud</code>参数，注意这里有一个字体必须自己设置中文字体，否则生成的词云不能出现中文，我用到的是<code>simkai.ttf</code>，下载地址：<a href="https://www.biptedu.cn/download/simkai.ttf" target="_blank" rel="external">simkai字体</a>。</p><h3 id="显示词云"><a href="#显示词云" class="headerlink" title="显示词云"></a>显示词云</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">iamge_colors = ImageColorGenerator(img)</div><div class="line">plt.imshow(my_wordcloud)</div><div class="line">plt.axis(<span class="string">'off'</span>)</div><div class="line">plt.show()</div><div class="line">my_wordcloud.to_file(<span class="string">'res.jpg'</span>)</div></pre></td></tr></table></figure><p>取图片的颜色作为词云的颜色，并显示词云。如下图<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/ciyun.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;利用wordcloud和jieba做一个词云&quot;&gt;&lt;a href=&quot;#利用wordcloud和jieba做一个词云&quot; class=&quot;headerlink&quot; title=&quot;利用wordcloud和jieba做一个词云&quot;&gt;&lt;/a&gt;利用&lt;code&gt;wordcloud&lt;/c
      
    
    </summary>
    
      <category term="小程序" scheme="http://sunlanchang.github.io/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
      <category term="小程序" scheme="http://sunlanchang.github.io/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
</feed>
