<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jason&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://sunlanchang.github.io/"/>
  <updated>2017-12-28T06:45:48.238Z</updated>
  <id>http://sunlanchang.github.io/</id>
  
  <author>
    <name>Jason Sun</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>计算机网络绪论和LAN（局域网）</title>
    <link href="http://sunlanchang.github.io/2017/12/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BB%AA%E8%AE%BA%E5%92%8CLAN%EF%BC%88%E5%B1%80%E5%9F%9F%E7%BD%91%EF%BC%89/"/>
    <id>http://sunlanchang.github.io/2017/12/28/计算机网络绪论和LAN（局域网）/</id>
    <published>2017-12-28T02:37:17.000Z</published>
    <updated>2017-12-28T06:45:48.238Z</updated>
    
    <content type="html"><![CDATA[<h1 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h1><p><strong>了解网络发展</strong></p><ul><li>面向终端的计算机网络</li><li>以通信子网为中心的计算机网络</li><li>体系结构标准化的网络</li><li>面向全球互连的计算机网络</li></ul><p><strong>网络拓扑结构分类</strong></p><ul><li>总线型结构</li><li>星型结构</li><li>环形结构</li><li>树形结构</li></ul><p><strong>网络协议 OSI 与 TCP/IP 的比较、协议各层的含义和基本传输单位</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/osi_tcpip.png" alt="OSI和TCP/IP区别" title="">                </div>                <div class="image-caption">OSI和TCP/IP区别</div>            </figure></p><ol><li>物理层PhysicalLayer:原始比特流的传输(传输基本单位比特bit)</li></ol><ul><li>提供传输数据的物理通路    </li><li>传输数据  </li><li>主要设备:中继器、集线器</li></ul><ol><li>数据链路层DataLinkLayer:建立相邻节点数据链路传输     (传输基本单位帧frame)</li></ol><ul><li>数据链路的建立、维护、拆除、指定拓扑结构并提供硬件寻址</li><li>数据组帧</li><li>控制帧的收发顺序</li><li>差错检测与恢复.流量控制</li><li>主要设备:二层交换机、网桥</li></ul><ol><li>网络层Network layer :基于IP地址的路由选路传输数据    (传输基本单位数据包packet)</li></ol><ul><li>路由选路</li><li>拥塞控制、差错检测与恢复</li><li>网络互联</li><li>主要设备:路由器</li></ul><ol><li>传输层Transport layer: 常规数据传递,面向连接或者无连接 (传输基本单位数据段segment)</li></ol><ul><li>流量控制</li></ul><ol><li><p>会话层Session layer: 建立会话关系</p></li><li><p>表示层Presentation layer:统一数据传输格式</p></li></ol><ul><li>数据压缩和解压</li><li>数据加密和解密</li></ul><ol><li>应用层Application layer :为用户应用程序提供服务接口</li></ol><h1 id="LAN"><a href="#LAN" class="headerlink" title="LAN"></a>LAN</h1><p><strong>常见 LAN 的拓扑结构类型及其特点分析</strong></p><ol><li>星形网的特点：</li></ol><ul><li>网络结构简单，便于管理（集中式）</li><li>处理机负载重（需处理所有的服务）</li><li>入网主机故障不影响整个网络的正常工作，中心处理机的故障将导致网络的瘫痪。</li></ul><ol><li>总线网的特点：</li></ol><ul><li>多台机器共用一条传输信道，信道利用率较高</li><li>同一时刻只能由两台计算机通信</li><li>某个结点的故障不影响网络的工作</li><li>网络的延伸距离有限，结点数有限</li></ul><ol><li>环形网特点：</li></ol><ul><li>实时性较好（信息在网中传输的最大时间固定）；</li><li>每个结点只与相邻两个结点有物理链路</li><li>传输控制机制比较简单</li><li>某个结点的故障将导致物理瘫痪</li><li>单个环网的结点数有限</li></ul><p><strong>LAN的扩展方法及其特点</strong></p><p><strong>交换机、路由器和集线器三者的应用比较</strong></p><ul><li>集线器和交换机区别：集线器采用的式共享带宽的工作方式，而交换机是独享带宽。</li><li>路由器与集线器交换机区别：路由器作用在于连接不同的网段并且找到网络中数据传输最合适的路径。<br>路由器与集线器交换机其他主要区别：</li><li>路由器工作在网络层，交换机和集线器工作在数据链路层和物理层。</li><li>路由器用IP地址转发数据，交换机利用MAC地址转发数据。</li><li>传统的交换机只能分割冲突域，不能分割广播域；而路由器可以分割广播域。</li><li>路由器可以提供防火墙功能。</li></ul><p><strong>VLAN 的实现技术</strong></p><ul><li>基于端口的VLAN</li><li>基于MAC地址的VLAN</li><li>基于第三层协议的VLAN</li><li>基于用户使用策略的VLAN</li></ul><p><strong>CSMA/CD（载波监听多路访问/冲突检测）</strong><br>含义：</p><ul><li>多路访问：许多计算机以多点接入的方式接入到总线网络。</li><li>载波监听：每个站在发送数据之前都要检测一下总线上是否有其它计算机在发送数据。</li><li>冲突检测：当几个站同时发送数据，总线上的信号电压摆动值将会增大（相互叠加）。发现冲突停止发送数据，等待一段随机时间再次发送。</li></ul><p>原理：先听后发，边听边发，冲突停发，随机重发。</p><p>特点：在发送数据时，需要不断的检测信道是否有其他主机也在发送数据。</p><p><strong>CSMA/CA（载波监听多路访问/冲突避免）</strong></p><p>原理：利用ACk信号来避免冲突的发生，也就是说，只有当客户端收到网络上返回的ACK信号后，才确认送出的数据已经正确到达目的。</p><p>CSMA/CD与CSMA/CA区别：  </p><ul><li>前者用于总线式以太网，后者用于无线网路</li><li>检测信道空闲方式不同：前者通过检测电缆中电压的变化，后者利用能量检测（ED）、载波检测（CS）、能量载波混合检测</li><li>对于无线局域网（WLAN）中某个节点来说来说，信号会出现覆盖的情况</li></ul><p><strong>基于逆向学习算法,掌握透明网桥转发表的生成过程</strong></p><p>透明指的是局域网上的站点并不知道所发送的帧经过那几个王巧，因为王巧对各站来说是看不见的。透明网桥是一种即插即用设备。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;绪论&quot;&gt;&lt;a href=&quot;#绪论&quot; class=&quot;headerlink&quot; title=&quot;绪论&quot;&gt;&lt;/a&gt;绪论&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;了解网络发展&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;面向终端的计算机网络&lt;/li&gt;
&lt;li&gt;以通信子网为中心的计算机网
      
    
    </summary>
    
      <category term="计算机网络" scheme="http://sunlanchang.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="http://sunlanchang.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络部分题目</title>
    <link href="http://sunlanchang.github.io/2017/12/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%83%A8%E5%88%86%E9%A2%98%E7%9B%AE/"/>
    <id>http://sunlanchang.github.io/2017/12/27/计算机网络部分题目/</id>
    <published>2017-12-27T05:03:43.000Z</published>
    <updated>2017-12-27T07:13:03.520Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简答题"><a href="#简答题" class="headerlink" title="简答题"></a>简答题</h1><ol><li><p>TCP/IP和OSI模型比较，有哪些相同或不同之处？请分别给出两个方面。<br> <strong>解答</strong>：1）相同点：都是层次化模型；都有应用层、传输层、网络层。2）不同点：OSI模型分为7层具有网络协议理论指导价值，但未得到应用。TCP/IP模型分为4层得到了应用。</p></li><li><p>简要叙述虚拟局域网的划分技术。<br> <strong>解答</strong>：1）按交换机端口划分。2）按IP地址划分。3）按MAC地址划分。4）按用户策略划分</p></li><li>常见的局域网络扩展方法有哪几种？各有什么特点？<br> <strong>解答</strong>：主要有三种。<ol><li>采用集线器，工作于物理层，具有冲突域和广播域，每台主机的带宽减少，总带宽不变。  </li><li>采用网桥或交换机，工作于数据链路层，具有广播域，隔离了冲突域，有广播风暴的风险。每台主机带宽不变，总带宽增加。</li><li>采用路由器，工作于网络层，隔离了广播域和冲突域，不会产生广播风暴，每台主机带宽不变，总带宽增加。</li></ol></li><li>按发展历史，防火墙技术有哪四种类型？请说明每类型的特点<br> <strong>解答</strong>：<ol><li>第一代防火墙：采用路由器，实现包过滤功能。</li><li>第二代防火墙：采用代理技术，提供网络服务级的控制，易于配置但速度较慢。</li><li>第三代防火墙：也叫状态监控功能的防火墙，可以对每一层数据进行检测和监控。</li><li>第四代防火墙：属于全方位的安全技术集成系统，采用安全内核、代理系统、多级过滤、安全服务器、鉴别和加密等关键技术。</li></ol></li></ol><h1 id="计算题"><a href="#计算题" class="headerlink" title="计算题"></a>计算题</h1><ol><li>考虑如图子网，有留个路由器。下面的矢量刚刚到达路由C：来自B的矢量为（5，0，8，12，6，2）（注：该矢量表示B到所有路由节点A，B，C，D，E，F的延迟分别为5，0，8，12，6，2一下同理）；来自D的矢量为（16,12,6,0,9,10）；来自E的矢量为（7,6,3,9,0,4）。经测量C到B、D和E的延迟分别为6、3、5。请使用距离矢量路由算法，按照下表格式，填写路由表C将要使用的输出线路以及期望的延迟。</li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/luyou.jpg" alt="路由图" title="">                </div>                <div class="image-caption">路由图</div>            </figure><table><thead><tr><th>节点号</th><th>延迟</th><th>输出线路</th></tr></thead><tbody><tr><td>A</td><td></td><td></td></tr><tr><td>B</td><td></td><td></td></tr><tr><td>C</td><td></td></tr></tbody></table><ol><li>一IP数据包的数据部分为4800字节（使用固定首部），需要分片为长度不超过1500字节的分组。请按照一下内容，给出具体的分片设计结果。<br> <strong>解答</strong>：本题没有唯一答案，首要保证每一分片数据是8的整数倍，而且分片数量以最少为佳。如果最后一片未能达到要求，则可以由系统或用户补0直到满足要求。其中的一种分片可以是：</li></ol><table><thead><tr><th>数据报片序号</th><th>数据长度</th><th>分组长度</th></tr></thead><tbody><tr><td>原始数据报</td><td>4800</td><td>4820</td></tr><tr><td>数据报片1</td><td>1480</td><td>1500</td></tr><tr><td>数据报片2</td><td>1480</td><td>1500</td></tr><tr><td>数据报片3</td><td>1480</td><td>1500</td></tr><tr><td>数据报片4</td><td>360</td><td>380</td></tr></tbody></table><ol><li>请在下图中直接画出数据<code>01011011001</code>的非归零码、曼彻斯特编码和差分曼彻斯特编码三种编码方式的信号波形。</li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/bianma.jpg" alt="编码" title="">                </div>                <div class="image-caption">编码</div>            </figure><ol><li><p>在RSA密钥密码体制中，如果p=13,q=31,d=7,求c的值。给出具体求解过程。<br><strong>解答</strong>：$n=p<em>q=13</em>31=403$，$z=(p-1)(q-1)=12<em>30=360$，$c</em>d=1mod360$ ，已知$d=7$，可以求$c=103$。</p></li><li><p>设TCP的拥塞窗口的慢启动阈值为16（单位为报文段），当拥塞窗口上升到24时，网络发生超时，TCP开始慢启动和拥塞避免。要求：1）画出拥塞控制示意图，要求描述清晰，有明确的坐标信息。2）求第18次传输时拥塞窗口大小是多少？<br><strong>解答</strong>：<br>1）当窗口为24时，实行拥塞控制避免，则新的阈值为24/2=12.拥塞控制示意图：<br><img src="/images/yongsekongzhi.jpg" alt="拥塞控制"><br>1)12；</p></li></ol><h1 id="综合题"><a href="#综合题" class="headerlink" title="综合题"></a>综合题</h1><ol><li>现在有一个公司需要创建企业网络，申请到的网络地址为<code>198.97.6.0</code>，该公司包括系统集成部、软件部、工程部和办公室4个部门，分别有28、21、14和8台计算机。为了便于开展工作，需要将这些部门划分子网管理。<br>1）如何划分子网？给出具体过程和子网掩码。（子网号全0或全1不考虑）<br>2）确定各个部门的网络地址，并写出分配给各个部门网络中的主机IP地址范围。<br><strong>解答</strong>：<br>1）采用子网划分的方法对该公司的网络进行划分。由于该公司包括4个部门，共需要划分4个子网。已知网络地址<code>198.97.6.0</code>是一个C类地址各部门的主机最多为28/由于子网号和主机号不允许是全0或全1,因此子网号的比特数为3即最多有$2^3-2=6$，个可分配的子网，主机号的比特数为5即每个子网最多有$2^5-2=30$个可分配的IP地址，因此子网掩码为<code>255.255.255.224</code>。<br>2）可用的6个子网的网络地址分别是：<code>198.97.6.32</code>、<code>198.97.6.64</code>、<code>198.97.6.96</code>、<code>198.97.6.128</code>、<code>198.97.6.160</code>、<code>198.97.6.192</code>，若选择前面4个，则有：<br>子网<code>198.97.6.32</code>的主机IP范围为：<code>198.97.6.33~198.97.6.62</code><br>子网<code>198.97.6.64</code>的主机IP范围为：<code>198.97.6.65~198.97.6.94</code><br>子网<code>198.97.6.96</code>的主机IP范围为：<code>198.97.6.97~198.97.6.126</code><br>子网<code>198.97.6.128</code>的主机IP范围为：<code>198.97.6.129~198.97.6.158</code>  </li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;简答题&quot;&gt;&lt;a href=&quot;#简答题&quot; class=&quot;headerlink&quot; title=&quot;简答题&quot;&gt;&lt;/a&gt;简答题&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;TCP/IP和OSI模型比较，有哪些相同或不同之处？请分别给出两个方面。&lt;br&gt; &lt;strong&gt;解答&lt;/stro
      
    
    </summary>
    
      <category term="计算机网络" scheme="http://sunlanchang.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="http://sunlanchang.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>事务与并发控制、存储过程和触发器</title>
    <link href="http://sunlanchang.github.io/2017/12/23/%E4%BA%8B%E5%8A%A1%E4%B8%8E%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%E3%80%81%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E5%92%8C%E8%A7%A6%E5%8F%91%E5%99%A8/"/>
    <id>http://sunlanchang.github.io/2017/12/23/事务与并发控制、存储过程和触发器/</id>
    <published>2017-12-23T03:08:42.000Z</published>
    <updated>2017-12-24T04:43:32.019Z</updated>
    
    <content type="html"><![CDATA[<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p><strong>4个基本特征(ACID)：</strong></p><ol><li>原子性(atomicity)：事务是数据库的逻辑工作单位，事务中的操作要么都做，要么都不做。</li><li>一致性(consistency)：事务中的操作如果有一部分成功，一部分失败，为避免数据库产生不一致状态，系统会自动将事务中已完成的操作撤销，是数据库回到事务开始前的状态。因此事务的一致性和原子性是密切相关的。</li><li>隔离性(isolation)：一个事务的内部操作及使用的数据对其他事务是隔离的，并发执行的各个事务不能相互干扰。</li><li>持久性(durability)：事务一旦体骄傲，则其对数据库中的数据的改变就是永久的，以后的操作或故障不会对事务的操作结果擦好女生任何影响。</li></ol><p><strong>2种类型</strong></p><ol><li>隐式事务：每一条数据操作语句都是一个事务（例如一条select语句）。</li><li>显式事务:有显式的开始和结束标记的事务。</li></ol><p><strong>并发控制措施</strong></p><ol><li>共享锁（只允许读）：对于读操作来说，可以有多个事务同时获得一个数据的共享锁，但阻止其他事务对该数据进行排他锁。</li><li>排他锁（只允许读、写）：一旦一个事务获得对某一数据的排他锁，就不允许其他事务对该数据进行任何封锁。</li></ol><h1 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h1><p><strong>创建和执行存储过程</strong></p><p>例如：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">create</span> proc pname</div><div class="line">    @sname <span class="built_in">char</span>(<span class="number">20</span>)</div><div class="line"><span class="keyword">as</span></div><div class="line">    <span class="keyword">select</span> * <span class="keyword">from</span> student <span class="keyword">where</span> sname=@sname;</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;事务&quot;&gt;&lt;a href=&quot;#事务&quot; class=&quot;headerlink&quot; title=&quot;事务&quot;&gt;&lt;/a&gt;事务&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;4个基本特征(ACID)：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;原子性(atomicity)：事务是数据库的逻辑工作
      
    
    </summary>
    
      <category term="数据库原理与应用" scheme="http://sunlanchang.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8/"/>
    
    
      <category term="数据库原理与应用" scheme="http://sunlanchang.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>数据库概述和结构、数据模型、关系数据库</title>
    <link href="http://sunlanchang.github.io/2017/12/22/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E8%BF%B0%E5%92%8C%E7%BB%93%E6%9E%84%E3%80%81%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B/"/>
    <id>http://sunlanchang.github.io/2017/12/22/数据库概述和结构、数据模型/</id>
    <published>2017-12-22T13:06:34.000Z</published>
    <updated>2017-12-23T03:09:24.167Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据库概览"><a href="#数据库概览" class="headerlink" title="数据库概览"></a>数据库概览</h1><p><strong>数据库系统</strong>本质是一个用计算机存储数据的系统，数据库是收集数据文件的仓库或容器，有永久存储、有组织和可共享的基本特点。<br>数据库管理相对于文件管理的优点：  </p><ol><li>数据相互关联</li><li>较少的数据冗余</li><li>程序与数据相互独立</li><li>保证数据的安全可靠</li><li>最大限度保证数据的正确性</li><li>数据可以共享并能保证数据的一致性</li></ol><h1 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h1><p><strong>数据模型及其分类</strong></p><ol><li>实体联系模型：涉及实体、属性、联系三方面（使用E-R图表示）。  </li><li>层次数据模型：用树形结构表示实体和实体之间的联系（有父节点和子节点）。</li><li>网状数据模型：用图形结构表示实体和实体之间的联系（可以没有父节点）。</li><li>关系数据模型：用关系表示实体和实体之间的联系。 </li></ol><p><strong>数据库模式结构</strong>：三级模式结构，由外向内是：外模式、模式、内模式</p><h2 id="关系模型的组成"><a href="#关系模型的组成" class="headerlink" title="关系模型的组成"></a>关系模型的组成</h2><p>关系数据结构：用二维表来组织数据，这个二维表在关系数据库中就称为关系。</p><p>关系操作  </p><ol><li>传统的关系运算：并、交、差、广义笛卡尔积</li><li>专门的关系运算：选择、投影、连接、除</li><li>有关的数据操作：查询、插入、删除、修改</li></ol><ul><li>实体完整性和参照完整性：系统级的约束，是必须满足的完整性约束。</li><li>用户自定义的完整性：应用级的约束，限制数据的取值范围等。</li></ul><ol><li>实体完整性：关系数据库中所有的表都必须有主码，而且表中不允许存在（1）无主码的记录（2）主码相同的记录</li><li>参照完整性：一个表中的关系的取值受到另一个表中关系的取值范围的约束（例如外码的选取）。</li><li>用户定义的完整性：一般是数据的取值范围的约束。</li></ol><p>关系代数及其应用  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据库概览&quot;&gt;&lt;a href=&quot;#数据库概览&quot; class=&quot;headerlink&quot; title=&quot;数据库概览&quot;&gt;&lt;/a&gt;数据库概览&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;数据库系统&lt;/strong&gt;本质是一个用计算机存储数据的系统，数据库是收集数据文件的仓库或容器，有永
      
    
    </summary>
    
      <category term="数据库原理与应用" scheme="http://sunlanchang.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8/"/>
    
    
      <category term="数据库原理与应用" scheme="http://sunlanchang.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>关系数据库规范化理论</title>
    <link href="http://sunlanchang.github.io/2017/12/18/%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A7%84%E8%8C%83%E5%8C%96%E7%90%86%E8%AE%BA/"/>
    <id>http://sunlanchang.github.io/2017/12/18/关系数据库规范化理论/</id>
    <published>2017-12-18T12:17:51.000Z</published>
    <updated>2017-12-18T13:35:13.561Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p><strong>函数依赖</strong>：如何构造一个合适的关系模式，应该构造几个关系模式，每个关系模式由哪些属性组成等，都是数据库的逻辑设计问题，其中各个属性之间的依赖关系就是函数依赖。<br>例如：选课表中$(Sno, Cno) \rightarrow Grade$即成绩依赖与学生学号和课程号，或Sno和Cno决定Y。  </p><p>设有关系模式R(A1,A2,…)，X和Y为R的一个子集，则：  </p><ol><li>如果$X \rightarrow Y$，但Y不包含于X，则称$X \rightarrow Y$是<strong>非平凡的函数依赖</strong>。</li><li>如果X不函数依赖与Y则记做$X \nrightarrow Y$。</li><li>如果$X \rightarrow Y$，则成为X为<strong>决定因子</strong>。</li><li>如果$X \rightarrow Y$并且$Y \rightarrow X$，则记做$X \leftrightarrow Y$。</li><li>如果$X \rightarrow Y$，并且对于X的每一个子集X1都有$X1 \nrightarrow Y$，则称<strong>Y完全依赖于X</strong>，若存在$X1 \rightarrow Y$反之为<strong>Y部分依赖于X</strong>。  </li><li>如果$X \rightarrow Y$（即非平凡函数依赖$Y \nrightarrow X$）并且$Y \rightarrow Z$ ，则称Z传递依赖与X。  </li></ol><p>设U表示关系模式E的属性全集，F表示R上的函数依赖集，则关系模式R可表示为R(U, F)  </p><ol><li><strong>候选码</strong>如果K为R中的属性或属性组，且K完全依赖于U，则K为R的候选码即K为决定R全部属性的最小属性组。  </li><li>关系R(u, F)中可能有多个候选码，选其中一个作为<strong>主码</strong>。  </li><li><strong>全码</strong>：候选码为整个属性组。  </li><li><strong>主属性</strong>为包含在任一候选码中的属性，反之为<strong>非主属性</strong>。  </li><li>用于建立关系表之间关联关系的属性称为<strong>外码</strong>。  </li></ol><h1 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h1><p><strong>第一范式</strong><br>不包含重复组属性（即不包含非原子项的属性）是第一范式的关系。<br><strong>第二范式</strong><br>如果R满足第一范式，并且R中每个非主属性都完全依赖于主码则R满足第二范式。（所有的属性都完全依赖主码，消除非主属性部的部分依赖）  </p><p>例如：$SC(Sno, Cno, Sname, Grade)$中$(Sno, Cno)$是主码，而又有$Sno \rightarrow Sname$，因此$Sname$部分依赖于$(Sno, Cno)$。</p><p>模式分解：  </p><ol><li>用组成主码的属性集合的每一个子集作为主码构成一个关系模式。</li><li>将依赖于这些主码的属性放置到相应的关系模式中。</li><li>最后去掉只由主码的子集构成的关系模式。</li></ol><p><strong>第三范式</strong><br>R(U, F)满足第二范式，并且不存在传递依赖。  </p><p>模式分解：</p><ol><li>对于不是候选码的每个决定因子，总关系模式中删去依赖于它的所有属性。</li><li>新建一个关系模式，新关系模式中包含在原关系模式中所有依赖于该决定因子的属性。</li><li>将决定因子作为新关系模式的主码。</li></ol><p><strong>BC范式</strong><br>当且仅当关系中的每个函数依赖的决定因子都是候选码时，R满足BC范式。<br>与第三范式区别：对于函数依赖$A \rightarrow B$，3NF允许B是主属性而A不是候选码，BCNF要求A必须是候选码。  </p><p><strong>关系模式的分解准则</strong><br>模式分解要满足：</p><ul><li>模式分解具有无损连接性；</li><li>模式分解能够保持函数依赖。</li></ul><ol><li><strong>无损连接</strong>是指分解后的关系通过自然连接可以恢复成原来的关系，即通过自然连接得到的关系与原来的关系相比，既不多出信息、又不丢失信息。</li><li><strong>保持函数依赖分解</strong>是指在模式的分解过程中，函数依赖不能丢失的特性，即模式分解不能破坏原来的语义。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;函数依赖&lt;/strong&gt;：如何构造一个合适的关系模式，应该构造几个关系模式，每个关系模式由哪些属性组成等，
      
    
    </summary>
    
      <category term="数据库原理与应用" scheme="http://sunlanchang.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8/"/>
    
    
      <category term="数据库原理与应用" scheme="http://sunlanchang.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>设置ssh私钥登录</title>
    <link href="http://sunlanchang.github.io/2017/12/16/%E8%AE%BE%E7%BD%AEssh%E7%A7%81%E9%92%A5%E7%99%BB%E5%BD%95/"/>
    <id>http://sunlanchang.github.io/2017/12/16/设置ssh私钥登录/</id>
    <published>2017-12-16T06:10:09.000Z</published>
    <updated>2017-12-16T06:21:13.073Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安装ssh"><a href="#安装ssh" class="headerlink" title="安装ssh"></a>安装ssh</h1><p><code>sudo apt install ssh</code>，若安装了，忽略这一步。</p><h1 id="ssh配置"><a href="#ssh配置" class="headerlink" title="ssh配置"></a>ssh配置</h1><p>主机A：10.0.5.199<br>主机B：10.0.5.198<br>需要配置主机A无密码登录主机B<br>先确保所有主机的防火墙处于关闭状态，这里是开放22端口。<br>在主机A上执行如下：<br>　1.　<code>$cd ~/.ssh</code><br>　2.　<code>$ssh-keygen -t rsa</code>，然后一直按回车键，就会按照默认的选项将生成的密钥保存在<code>.ssh/id_rsa</code>文件中。<br>　3.　<code>$cp id_rsa.pub authorized_keys</code> 这步完成后，正常情况下就可以无密码登录本机了，即ssh localhost，无需输入密码。<br>　4.　<code>$scp authorized_keys summer@10.0.5.198:/home/summer/.ssh</code>，把刚刚产生的authorized_keys文件拷一份到主机B上.　　<br>　5.　<code>$chmod 600 authorized_keys</code>，进入主机B的.ssh目录，改变authorized_keys文件的许可权限。  </p><p><strong>Note：</strong><br>(4和5可以合成一步，执行:  <code>$ssh-copy-id -i summer@10.0.5.198</code>)</p><p><strong>参考</strong>  </p><blockquote><p><a href="http://www.cnblogs.com/jdksummer/articles/2521550.html" target="_blank" rel="external">http://www.cnblogs.com/jdksummer/articles/2521550.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;安装ssh&quot;&gt;&lt;a href=&quot;#安装ssh&quot; class=&quot;headerlink&quot; title=&quot;安装ssh&quot;&gt;&lt;/a&gt;安装ssh&lt;/h1&gt;&lt;p&gt;&lt;code&gt;sudo apt install ssh&lt;/code&gt;，若安装了，忽略这一步。&lt;/p&gt;
&lt;h1 id=&quot;
      
    
    </summary>
    
      <category term="Other" scheme="http://sunlanchang.github.io/categories/Other/"/>
    
    
      <category term="Other" scheme="http://sunlanchang.github.io/tags/Other/"/>
    
  </entry>
  
  <entry>
    <title>HTTP、TCP/IP协议、socket的区别</title>
    <link href="http://sunlanchang.github.io/2017/12/15/HTTP%E3%80%81TCP-IP%E5%8D%8F%E8%AE%AE%E3%80%81socket%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://sunlanchang.github.io/2017/12/15/HTTP、TCP-IP协议、socket的区别/</id>
    <published>2017-12-15T14:36:51.000Z</published>
    <updated>2017-12-15T14:51:24.694Z</updated>
    
    <content type="html"><![CDATA[<p>在配置Shadowsocks客户端遇到了<code>Socket</code>接口的问题，特地查阅了一下TCP/IP协议层的<code>Socket</code>，总的来说它是TCP/IP的一个抽象的接口。</p><h1 id="TCP-IP连接"><a href="#TCP-IP连接" class="headerlink" title="TCP/IP连接"></a>TCP/IP连接</h1><p>手机能够使用联网功能是因为手机底层实现了TCP/IP协议，可以使手机终端通过无线网络建立TCP连接。TCP协议可以对上层网络提供接口，使上层网络数据的传输建立在“无差别”的网络之上。<br><strong>建立起一个TCP连接需要经过“三次握手”：</strong>  </p><ul><li>第一次握手：客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认；</li><li>第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；</li><li>第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。<br>握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。断开连接时服务器和客户端均可以主动发起断开TCP连接的请求，断开过程需要经过“四次握手”（过程就不细写了，就是服务器和客户端交互，最终确定断开。<h1 id="HTTP连接"><a href="#HTTP连接" class="headerlink" title="HTTP连接"></a>HTTP连接</h1>HTTP协议即超文本传送协议(Hypertext Transfer Protocol )，是Web联网的基础，也是手机联网常用的协议之一。<br><strong>HTTP协议是建立在TCP协议之上的一种应用。</strong><br>HTTP连接最显著的特点是客户端发送的每次请求都需要服务器回送响应，在请求结束后，会主动释放连接。从建立连接到关闭连接的过程称为“一次连接”。</li><li>在HTTP 1.0中，客户端的每次请求都要求建立一次单独的连接，在处理完本次请求后，就自动释放连接。</li><li>在HTTP 1.1中则可以在一次连接中处理多个请求，并且多个请求可以重叠进行，不需要等待一个请求结束后再发送下一个请求。<br>由于HTTP在每次请求结束后都会主动释放连接，因此HTTP连接是一种“短连接”，要保持客户端程序的在线状态，需要不断地向服务器发起连接请求。通常的做法是即时不需要获得任何数据，客户端也保持每隔一段固定的时间向服务器发送一次“保持连接”的请求，服务器在收到该请求后对客户端进行回复，表明知道客户端“在线”。若服务器长时间无法收到客户端的请求，则认为客户端“下线”，若客户端长时间无法收到服务器的回复，则认为网络已经断开。<h1 id="SOCKET原理"><a href="#SOCKET原理" class="headerlink" title="SOCKET原理"></a>SOCKET原理</h1><strong>套接字（socket）概念</strong><br>套接字（socket）是通信的基石，是支持TCP/IP协议的网络通信的基本操作单元。它是网络通信过程中端点的抽象表示，包含进行网络通信必须的五种信息：连接使用的协议，本地主机的IP地址，本地进程的协议端口，远地主机的IP地址，远地进程的协议端口。<br>应用层通过传输层进行数据通信时，TCP会遇到同时为多个应用程序进程提供并发服务的问题。多个TCP连接或多个应用程序进程可能需要通过同一个 TCP协议端口传输数据。为了区别不同的应用程序进程和连接，许多计算机操作系统为应用程序与TCP／IP协议交互提供了套接字(Socket)接口。应用层可以和传输层通过Socket接口，区分来自不同应用程序进程或网络连接的通信，实现数据传输的并发服务。<br><strong>建立socket连接</strong><br>建立Socket连接至少需要一对套接字，其中一个运行于客户端，称为ClientSocket ，另一个运行于服务器端，称为ServerSocket 。<br>套接字之间的连接过程分为三个步骤：服务器监听，客户端请求，连接确认。</li><li>服务器监听：服务器端套接字并不定位具体的客户端套接字，而是处于等待连接的状态，实时监控网络状态，等待客户端的连接请求。</li><li>客户端请求：指客户端的套接字提出连接请求，要连接的目标是服务器端的套接字。为此，客户端的套接字必须首先描述它要连接的服务器的套接字，指出服务器端套接字的地址和端口号，然后就向服务器端套接字提出连接请求。</li><li>连接确认：当服务器端套接字监听到或者说接收到客户端套接字的连接请求时，就响应客户端套接字的请求，建立一个新的线程，把服务器端套接字的描述发给客户端，一旦客户端确认了此描述，双方就正式建立连接。而服务器端套接字继续处于监听状态，继续接收其他客户端套接字的连接请求。<h1 id="SOCKET连接与TCP-IP连接"><a href="#SOCKET连接与TCP-IP连接" class="headerlink" title="SOCKET连接与TCP/IP连接"></a>SOCKET连接与TCP/IP连接</h1>创建Socket连接时，可以指定使用的传输层协议，Socket可以支持不同的传输层协议（TCP或UDP），当使用TCP协议进行连接时，该Socket连接就是一个TCP连接。<br>socket则是对TCP/IP协议的封装和应用（程序员层面上）。也可以说，TPC/IP协议是传输层协议，主要解决数据 如何在网络中传输，而HTTP是应用层协议，主要解决如何包装数据。关于TCP/IP和HTTP协议的关系，网络有一段比较容易理解的介绍：  <blockquote><p>“我们在传输数据时，可以只使用（传输层）TCP/IP协议，但是那样的话，如 果没有应用层，便无法识别数据内容，如果想要使传输的数据有意义，则必须使用到应用层协议，应用层协议有很多，比如HTTP、FTP、TELNET等，也 可以自己定义应用层协议。WEB使用HTTP协议作应用层协议，以封装HTTP文本信息，然后使用TCP/IP做传输层协议将它发到网络上。”  </p></blockquote></li></ul><p>我们平时说的最多的socket是什么呢，实际上socket是对TCP/IP协议的封装，Socket本身并不是协议，而是一个调用接口（API），通过Socket，我们才能使用TCP/IP协议。 实际上，Socket跟TCP/IP协议没有必然的联系。Socket编程接口在设计的时候，就希望也能适应其他的网络协议。所以说，Socket的出现 只是使得程序员更方便地使用TCP/IP协议栈而已，是对TCP/IP协议的抽象，从而形成了我们知道的一些最基本的函数接口，比如create、 listen、connect、accept、send、read和write等等。网络有一段关于socket和TCP/IP协议关系的说法比较容易理解：<br>“TCP/IP只是一个协议栈，就像操作系统的运行机制一样，必须要具体实现，同时还要提供对外的操作接口。这个就像操作系统会提供标准的编程接口，比如win32编程接口一样，TCP/IP也要提供可供程序员做网络开发所用的接口，这就是Socket编程接口。”<br>实际上，传输层的TCP是基于网络层的IP协议的，而应用层的HTTP协议又是基于传输层的TCP协议的，而Socket本身不算是协议，就像上面所说，它只是提供了一个针对TCP或者UDP编程的接口。socket是对端口通信开发的工具,它要更底层一些.</p><h1 id="Socket连接与HTTP连接"><a href="#Socket连接与HTTP连接" class="headerlink" title="Socket连接与HTTP连接"></a>Socket连接与HTTP连接</h1><p>由于通常情况下Socket连接就是TCP连接，因此Socket连接一旦建立，通信双方即可开始相互发送数据内容，直到双方连接断开。但在实际网络应用中，客户端到服务器之间的通信往往需要穿越多个中间节点，例如路由器、网关、防火墙等，大部分防火墙默认会关闭长时间处于非活跃状态的连接而导致 Socket 连接断连，因此需要通过轮询告诉网络，该连接处于活跃状态。<br> 而HTTP连接使用的是“请求—响应”的方式，不仅在请求时需要先建立连接，而且需要客户端向服务器发出请求后，服务器端才能回复数据。<br>很多情况下，需要服务器端主动向客户端推送数据，保持客户端与服务器数据的实时与同步。此时若双方建立的是Socket连接，服务器就可以直接将数据传送给客户端；若双方建立的是HTTP连接，则服务器需要等到客户端发送一次请求后才能将数据传回给客户端，因此，客户端定时向服务器端发送连接请求，不仅可以保持在线，同时也是在“询问”服务器是否有新的数据，如果有就将数据传给客户端。<br>http协议是应用层的协义 有个比较形象的描述：HTTP是轿车，提供了封装或者显示数据的具体形式；Socket是发动机，提供了网络通信的能力。<br><strong>参考：</strong>  </p><blockquote><p><a href="https://baike.baidu.com/item/socket/281150" target="_blank" rel="external">https://baike.baidu.com/item/socket/281150</a><br><a href="https://www.2cto.com/net/201211/166537.html" target="_blank" rel="external">https://www.2cto.com/net/201211/166537.html</a><br><a href="http://jingyan.baidu.com/article/08b6a591e07ecc14a80922f1.html" target="_blank" rel="external">http://jingyan.baidu.com/article/08b6a591e07ecc14a80922f1.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在配置Shadowsocks客户端遇到了&lt;code&gt;Socket&lt;/code&gt;接口的问题，特地查阅了一下TCP/IP协议层的&lt;code&gt;Socket&lt;/code&gt;，总的来说它是TCP/IP的一个抽象的接口。&lt;/p&gt;
&lt;h1 id=&quot;TCP-IP连接&quot;&gt;&lt;a href=&quot;#T
      
    
    </summary>
    
      <category term="计算机网络" scheme="http://sunlanchang.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="http://sunlanchang.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>存储系统</title>
    <link href="http://sunlanchang.github.io/2017/12/14/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/"/>
    <id>http://sunlanchang.github.io/2017/12/14/存储系统/</id>
    <published>2017-12-14T12:58:55.000Z</published>
    <updated>2017-12-22T14:58:38.861Z</updated>
    
    <content type="html"><![CDATA[<h1 id="三层体系结构的特点"><a href="#三层体系结构的特点" class="headerlink" title="三层体系结构的特点"></a>三层体系结构的特点</h1><p>三层体系结构依次是：Cache、主存、辅存。  </p><ul><li>cache-主存:在CPU和主存之间增加一级速度快、但容量较小且每位价格较高的高速缓冲存储Cache)。借助于辅助软硬件，它与主存构成一个有机的整体，以弥补主存速度的不足。这个层次的工作主要由硬件实现。  </li><li>主存-辅存:这个层次的目的是为了弥补主存容量的它是在主存外面增加一个容量更大、每位价格更速度更慢的存储器(称为辅存，一般是硬盘)。它辅助软硬件的作用，构成一个整体。“主存-辅存常被用来实现虚拟存储器，向编程人员提供大量空间。<h1 id="Cache的特点、作用、工作原理"><a href="#Cache的特点、作用、工作原理" class="headerlink" title="Cache的特点、作用、工作原理"></a>Cache的特点、作用、工作原理</h1></li></ul><ol><li>特点是速度快</li><li>作用：弥补CPU与主存之间的运行速度的差距。</li><li>工作原理：根据数据分布的局部性和时间局部性在CPU和主存之间设置Cache。 <h1 id="虚拟存储器的特点、工作原理、管理方式"><a href="#虚拟存储器的特点、工作原理、管理方式" class="headerlink" title="虚拟存储器的特点、工作原理、管理方式"></a>虚拟存储器的特点、工作原理、管理方式</h1>虚拟存储器指的是“主存-辅存”层次。<br>虚拟存储器的作用：<br>虚拟存储器，Virtual Machine，简称VM，是对主存（DRAM）的一种抽象，是计算机系统中最重要的概念之一。计算机中有各种存储器，而VM的存在，就是为了帮助我们有效地管理这些存储器，减少错误，提供一种简单的数据交互方法。VM，将主存看成是一个存储在磁盘上的地址空间的高速缓存，在主存中只保存活动区域，并根据需要在磁盘和主存中来回传送数据，而且为每个进程提供了一致的地址空间，并保护这个地址空间不被其它的进程破坏</li></ol><p><strong>段式</strong>  </p><ol><li>段式存储是根据程序逻辑，给程序分段。使得每段大小不同。这种虚拟地址划分方法适合程序设计</li><li>段式存储的虚拟地址由段号和段内偏移地址组成。段式虚拟存储器到物理地址的映射通过段表实现</li><li>段式虚拟存储会造成空页</li></ol><p><strong>页式</strong>  </p><ol><li>概念<ol><li>程序员在比实际主存大得多的逻辑地址空间中编写程序</li><li>程序执行时，把当前需要的程序段和数据块掉入主存，其他暂不使用的放在磁盘上</li><li>执行指令时，通过硬件将逻辑地址转化为物理地址。虚拟地址高位为虚页号，低位为页内偏移地址</li><li>当程序发生数据访问或程序访问失效(缺页时)，由操作系统把信息从磁盘调入主存中</li></ol></li><li>分页  <ol><li>基本思想：内存被分成固定长度且长度较小的存储块（页框，实页，物理页），每个进程也被划分为固定长度的程序块（页，虚页，逻辑页），通过页表，实现逻辑地址想物理地址转化</li><li>逻辑地址：程序中指令所使用的地址（进程所在地址空间）</li><li>物理地址：存放指令或数据的实际内存地址</li></ol></li><li>页表结构<br>页表的首地址放在基址寄存器。采用基址寻址方式<br>每个页表项前面有一个虚页号：从0开始递增的序号。页表项又分为几个结构：<br>（1）装入位：该页是否在内存中<br>（2）修改位：该也在内存中是否被修改<br>（3）替换控制位：用于clock算法<br>（4）其他<br>（5）实页号（8进制）<br><strong>段页式</strong>  </li><li>段页式虚拟存储，先把程序按照逻辑分成段，再把每段分成固定大小的页。<br>程序对主存的调入调出是按照页面进行的。但他有可以根据段实现共享和保护。</li><li>缺点是段页式虚拟地址转换成物理地址需要查询2个表：段表和页表。段表找到相应页表的位置，页表找到想也页的位置。</li><li>段页式细腻地址的结构可以为以下形式：<br>程序地址： <code>用户号(进程pid) | 段号 | 页号 | 页内偏移地址</code><h1 id="Cache的地址映像"><a href="#Cache的地址映像" class="headerlink" title="Cache的地址映像"></a>Cache的地址映像</h1><strong>直接映像</strong><br>j= i mod Cache的块数<br>把主存分成若干区，每区与Cache大小相同。区内分块，主存每个区中块的大小和Cache中块的大小相等，主存中每个区包含的块的个数与Cache中块的个数相等。任意一个主存块只能映像到Cache中唯一指定的块中，即相同块号的位置。主存地址分为三部分：区号、块号和块内地址，Cache地址分为：块号和块内地址。直接映像方式下，数据块只能映像到Cache中唯一指定的位置，故不存在替换算法的问题。它不同于全相连Cache，地址仅需比较一次。<br>特点：地址变换简单、速度快，可直接由主存地址提取出Cache地址。但不灵活，块冲突率较高，Cache空间得不到充分利用。<br>公式：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">主存地址位数 ＝ 区号 + 区内分块号 + 块内地址</div><div class="line">Cache地址位数 ＝ 块号+块内地址</div></pre></td></tr></table></figure></li></ol><p><strong>全相联映像</strong><br>计算主存地址的各字段的位数、命中率。<br>主存中任何一个块均可以映像装入到Cache中的任何一个块的位置上。主存地址分为块号和块内地址两部分，Cache地址也分为块号和块内地址。Cache的块内地址部分直接取自主存地址的块内地址段。主存块号和Cache块号不相同，Cache块号根据主存块号从块表中查找。Cache保存的各数据块互不相关，Cache必须对每个块和块自身的地址加以存储。当请求数据时，Cache控制器要把请求地址同所有的地址加以比较，进行确认。<br>特点：灵活，块冲突率低，只有在Cache中的块全部装满后才会出现冲突，Cache利用率高。但地址变换机构复杂，地址变换速度慢，成本高。<br>公式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">主存地址位数 ＝ 块号 + 块内地址</div><div class="line">Cache地址位数＝块号 + 块内地址。</div></pre></td></tr></table></figure></p><p><strong>组相联映像</strong><br>j=(i mod Cache的组数)×Cache每组块数+k<br>组相连映像是前两种方式的折衷。主存按Cache容量分区，每个区分为若干组，每组包含若干块。Cache也进行同样的分组和分块。主存中一个组内的块数与Cache中一个组内的块数相等。组间采用直接方式，组内采用全相连方式。组的容量＝1时，即直接映像，组的容量＝整个Cache的容量时，即全相连映像。Cache的存在对于程序员透明，Cache的地址变换和数据块的替换算法都采用硬件实现。<br>公式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">主存地址位数 ＝ 区号 + 组号 + 主存块号 + 块内地址</div><div class="line">Cache地址位数 ＝ 组号 + 组内块号 + 块内地址</div></pre></td></tr></table></figure></p><h1 id="替换策略（FIFO和LRU）"><a href="#替换策略（FIFO和LRU）" class="headerlink" title="替换策略（FIFO和LRU）"></a>替换策略（FIFO和LRU）</h1><p>略</p><h1 id="设置了Cache与未设置Cache时计算机运行速度的计算、内存平均存取时间的计算。"><a href="#设置了Cache与未设置Cache时计算机运行速度的计算、内存平均存取时间的计算。" class="headerlink" title="设置了Cache与未设置Cache时计算机运行速度的计算、内存平均存取时间的计算。"></a>设置了Cache与未设置Cache时计算机运行速度的计算、内存平均存取时间的计算。</h1><p>平均存取时间=h<em>tc+(1–h) </em>(tm)</p><h1 id="辅助存储器的性能参数的计算"><a href="#辅助存储器的性能参数的计算" class="headerlink" title="辅助存储器的性能参数的计算"></a>辅助存储器的性能参数的计算</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;三层体系结构的特点&quot;&gt;&lt;a href=&quot;#三层体系结构的特点&quot; class=&quot;headerlink&quot; title=&quot;三层体系结构的特点&quot;&gt;&lt;/a&gt;三层体系结构的特点&lt;/h1&gt;&lt;p&gt;三层体系结构依次是：Cache、主存、辅存。  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;cach
      
    
    </summary>
    
      <category term="计算机组成原理" scheme="http://sunlanchang.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="计算机组成原理" scheme="http://sunlanchang.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>中央处理器</title>
    <link href="http://sunlanchang.github.io/2017/12/14/%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/"/>
    <id>http://sunlanchang.github.io/2017/12/14/中央处理器/</id>
    <published>2017-12-14T12:18:28.000Z</published>
    <updated>2017-12-22T14:56:32.305Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p><strong>程序计数器PC</strong><br>即指令地址寄存器。用来存放当前正在执行的指令地址，或将要执行的下一条指令地址。<br><strong>指令寄存器IR</strong><br>用来存放当前正在执行的指令，以便在指令执行过程中控制完成一条指令的全部功能。<br><strong>指令译码器</strong><br>对指令寄存器IR中的操作码进行分析解释，产生相应的控制信号。<br><strong>MAR、MDR、标志寄存器</strong><br>地址寄存器，数据寄存器。标志寄存器包含CNVZ四个标志位。<br><strong>时钟周期、指令周期、机器周期</strong>  </p><ol><li>时钟周期：是计算机中最基本的、最小的时间单位。在一个时钟周期内,CPU仅完成一个最基本的动作。  </li><li>机器周期：在计算机中,为了便于管理,常把一条指令的执行过程划分为若干个阶段,每一阶段完成一项工作。例如,取指令、存储器读、存储器写等,这每一项工作称为一个基本操作。完成一个基本操作所需要的时间称为机器周期。  </li><li>指令周期：执行一条指令所需要的时间,一般由若干个机器周期组成。指令不同,所需的机器周期也不同。       对于一些简单的的单字节指令,在取指令周期中,指令取出到指令寄存器后,立即译码执行,不再需要其它的机器周期。对于一些比较复杂的指令,例如转移指令、乘法指令,则需要两个或者两个以上的机器周期。    通常含一个机器周期的指令称为单周期指令,包含两个机器周期的指令称为双周期指令。  </li></ol><p><strong>控制存储器</strong><br>为程序一般存放在专用的存储器中，该存储器主要存放控制命令（信号）和下一条执行的微指令地址（下址）。执行一条微指令就是执行一段存放在控制存储器中的微程序。</p><h1 id="控制器产生控制信号有两种方法：微程序控制、硬布线控制（组合逻辑控制）"><a href="#控制器产生控制信号有两种方法：微程序控制、硬布线控制（组合逻辑控制）" class="headerlink" title="控制器产生控制信号有两种方法：微程序控制、硬布线控制（组合逻辑控制）"></a>控制器产生控制信号有两种方法：微程序控制、硬布线控制（组合逻辑控制）</h1><p>略</p><h1 id="计算机取指和取操作数的过程及数据通路"><a href="#计算机取指和取操作数的过程及数据通路" class="headerlink" title="计算机取指和取操作数的过程及数据通路"></a>计算机取指和取操作数的过程及数据通路</h1><p>略</p><h1 id="用微程序设计方案设计微指令"><a href="#用微程序设计方案设计微指令" class="headerlink" title="用微程序设计方案设计微指令"></a>用微程序设计方案设计微指令</h1><p>微指令控制字段的方法：</p><ol><li>直接控制法</li><li>字段直接编译法</li><li>字段间接编译法<h1 id="指令流水的概念、影响流水线性能的因素及解决方法"><a href="#指令流水的概念、影响流水线性能的因素及解决方法" class="headerlink" title="指令流水的概念、影响流水线性能的因素及解决方法"></a>指令流水的概念、影响流水线性能的因素及解决方法</h1></li><li>为提高CPU利用率，加快执行速度，将指令分为若干个阶段，可并行执行不同指令的不同阶段，从而多个指令可以同时执行。在有效地控制了流水线阻塞的情况下，流水线可大大提高指令执行速度。经典的五级流水线：取址、译码/读寄存器、执行/计算有效地址、访问内存（读或写）、结果写回寄存器。</li><li>流水线阻塞的情况有三种：<br>　　1. 结构相关：指令重叠执行的过程中，硬件资源满足不了指令重叠执行的要求，发生资源冲突，这时将产生结构相关。解决的办法是增加硬件资源。<br>　　2. 数据相关：当一条指令需要前面某条指令的执行结果，而两者正在并行执行的情况下，将产生数据相关。解决方式：数据重定向，或称为旁路技术。<br>　　3. 控制相关：有跳转语句、分支指令，或其他改变IP值的指令，将产生控制相关。解决方法：分支预测技术，投机执行，延迟分支。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;程序计数器PC&lt;/strong&gt;&lt;br&gt;即指令地址寄存器。用来存放当前正在执行的指令地址，或将要执行的下一条
      
    
    </summary>
    
      <category term="计算机组成原理" scheme="http://sunlanchang.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="计算机组成原理" scheme="http://sunlanchang.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>指令系统</title>
    <link href="http://sunlanchang.github.io/2017/12/14/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/"/>
    <id>http://sunlanchang.github.io/2017/12/14/指令系统/</id>
    <published>2017-12-14T12:03:39.000Z</published>
    <updated>2017-12-27T04:40:46.570Z</updated>
    
    <content type="html"><![CDATA[<h1 id="指令操作码、地址码的设计方法"><a href="#指令操作码、地址码的设计方法" class="headerlink" title="指令操作码、地址码的设计方法"></a>指令操作码、地址码的设计方法</h1><p>略</p><h1 id="常用的寻址方式及其特点"><a href="#常用的寻址方式及其特点" class="headerlink" title="常用的寻址方式及其特点"></a>常用的寻址方式及其特点</h1><p>直接寻址、寄存器寻址、基址寻址、变址寻址、间接寻址（寄存器间址、存储器间址）、相对寻址、立即数寻址。<br>参考：<a href="https://sunlanchang.github.io/2017/11/21/%E5%9B%BE%E8%A7%A3%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F/">图解寻址方式</a></p><h1 id="基本概念：堆栈、标志位、指令字长"><a href="#基本概念：堆栈、标志位、指令字长" class="headerlink" title="基本概念：堆栈、标志位、指令字长"></a>基本概念：堆栈、标志位、指令字长</h1><ol><li>标志位：C（产生进位或借位）、V（结果溢出）、Z（结果为0）、N（结果为负）</li><li>指令字长分为单字长指令和双字长指令。 </li></ol><h1 id="执行一条指令的过程"><a href="#执行一条指令的过程" class="headerlink" title="执行一条指令的过程"></a>执行一条指令的过程</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/shujutonglu.png" alt="CPU与主存连接示意图" title="">                </div>                <div class="image-caption">CPU与主存连接示意图</div>            </figure><ol><li><strong>取指令</strong> ：PC -&gt; MAR -&gt; M -&gt; IR -&gt; 微操作信号发生器</li><li><strong>执行指令</strong> ：IR -&gt; MAR -&gt; M -&gt; MDR ….（后续执行过程依照不同指令而不同）</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;指令操作码、地址码的设计方法&quot;&gt;&lt;a href=&quot;#指令操作码、地址码的设计方法&quot; class=&quot;headerlink&quot; title=&quot;指令操作码、地址码的设计方法&quot;&gt;&lt;/a&gt;指令操作码、地址码的设计方法&lt;/h1&gt;&lt;p&gt;略&lt;/p&gt;
&lt;h1 id=&quot;常用的寻址方式及
      
    
    </summary>
    
      <category term="计算机组成原理" scheme="http://sunlanchang.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="计算机组成原理" scheme="http://sunlanchang.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>主存储器</title>
    <link href="http://sunlanchang.github.io/2017/12/14/%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8/"/>
    <id>http://sunlanchang.github.io/2017/12/14/主存储器/</id>
    <published>2017-12-14T11:46:19.000Z</published>
    <updated>2017-12-22T14:58:03.149Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RAM和ROM的特性"><a href="#RAM和ROM的特性" class="headerlink" title="RAM和ROM的特性"></a>RAM和ROM的特性</h1><ol><li>RAM：通过指令可以随机的个别的对各个存储但愿进行访问读写的存储器，访问时间与存储单元的地址无关。停电会造成信息丢失，具有易失性。</li><li>ROM：只能读不能写的存储器，具有非易失性。（ROM不是外部存储器例如硬盘等）</li></ol><p><strong>Note</strong><br>主存包括RAM和ROM，CPU通过不同的编址方式区别它们。</p><h1 id="SRAM、DRAM"><a href="#SRAM、DRAM" class="headerlink" title="SRAM、DRAM"></a>SRAM、DRAM</h1><ol><li>两者都是RAM类型的存储器。</li><li>DRAM容量大，价格便宜，功率小，常用做主存储器的主要元件。</li><li>SRAM速度快，一般用作容量不大的高速存储器（例如高速缓冲存储器Cache）。</li></ol><h1 id="存储器容量的扩展"><a href="#存储器容量的扩展" class="headerlink" title="存储器容量的扩展"></a>存储器容量的扩展</h1><ol><li>字扩展</li><li>位扩展</li><li>字位扩展</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;RAM和ROM的特性&quot;&gt;&lt;a href=&quot;#RAM和ROM的特性&quot; class=&quot;headerlink&quot; title=&quot;RAM和ROM的特性&quot;&gt;&lt;/a&gt;RAM和ROM的特性&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;RAM：通过指令可以随机的个别的对各个存储但愿进行访问读写的存储
      
    
    </summary>
    
      <category term="计算机组成原理" scheme="http://sunlanchang.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="计算机组成原理" scheme="http://sunlanchang.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>计算机运算方法和运算部件</title>
    <link href="http://sunlanchang.github.io/2017/12/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E9%83%A8%E4%BB%B6/"/>
    <id>http://sunlanchang.github.io/2017/12/14/计算机运算方法和运算部件/</id>
    <published>2017-12-14T10:56:44.000Z</published>
    <updated>2017-12-22T14:58:55.469Z</updated>
    
    <content type="html"><![CDATA[<h1 id="十进制数、二进制数、十六进制数的相互转换"><a href="#十进制数、二进制数、十六进制数的相互转换" class="headerlink" title="十进制数、二进制数、十六进制数的相互转换"></a>十进制数、二进制数、十六进制数的相互转换</h1><ol><li>整数十进制转二进制有模2取余法。</li><li>小数转二进制有乘2取整法。</li><li>二进制转十六进制：二进制从低位到高位四个为一组（高位不够补0），转换为十六进制。反之为十六进制转换二进制。</li><li>十进制转十六进制：第一种先把十六进制转换为二进制，再把二进制转换为十六进制。第二种模16取余法，十六进制即为倒序的余数。</li></ol><h1 id="机器数的表示方法：原码、补码、反码、移码"><a href="#机器数的表示方法：原码、补码、反码、移码" class="headerlink" title="机器数的表示方法：原码、补码、反码、移码"></a>机器数的表示方法：原码、补码、反码、移码</h1><ol><li>原码：用0、1取代符号位。0表示正数，1表示负数。与真值最接近的表示形式。</li><li>补码：机器数的最高位为符号位。0表示正数，1表示负数。正数的补码是本身，负数的补码是取反再加1，0的补码是0。</li><li>反码：符号位不变各位取反。</li><li>移码：符号位取反的补码。用来表示浮点数的阶码。</li></ol><p><strong>Note</strong>  </p><ol><li>0表示形式唯一的是补码和移码</li><li>补码左移补0，右移补1</li></ol><h1 id="补码加减法运算时"><a href="#补码加减法运算时" class="headerlink" title="补码加减法运算时"></a>补码加减法运算时</h1><p>采用双符号位运算，若双符号位为00或者11则不溢出，反之溢出。</p><h1 id="浮点数表示方法"><a href="#浮点数表示方法" class="headerlink" title="浮点数表示方法"></a>浮点数表示方法</h1><p>$$N=MR^E$$<br>| 尾数符号位（Ms） | 阶码（E） | 尾数（M） |<br>| :————–: | :——-: | :——-: |</p><ol><li>Ms为尾数的符号位，设置在最高位。</li><li>E为阶码，一般为整数，其中有一位符号位，设置在E的最高位，用来表示正阶或负阶。</li><li>M为尾数，为了保证数据精度，尾数通常用规格化（尾数最高位不能为0）表示：当R=2且尾数值不为0时，其绝对值应大于或等于$(0.5)_{10}$。对于非规格化的浮点数通过将尾数左移或右移并修改阶码值使之满足规格化要求。</li></ol><h1 id="奇偶校验码"><a href="#奇偶校验码" class="headerlink" title="奇偶校验码"></a>奇偶校验码</h1><p>奇校验：将机器数凑成奇数个1<br>偶校验：将机器数凑成偶数个</p><p>数据：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span> </div><div class="line"><span class="number">0</span>  <span class="number">0</span>  <span class="number">1</span> </div><div class="line"><span class="number">1</span>  <span class="number">1</span>  <span class="number">0</span></div></pre></td></tr></table></figure></p><p>奇校验<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span> </div><div class="line"><span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">1</span> </div><div class="line"><span class="number">1</span>  <span class="number">1</span>  <span class="number">1</span>  <span class="number">0</span></div></pre></td></tr></table></figure></p><p>偶校验<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span> </div><div class="line"><span class="number">1</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">1</span> </div><div class="line"><span class="number">0</span>  <span class="number">1</span>  <span class="number">1</span>  <span class="number">0</span></div></pre></td></tr></table></figure></p><h1 id="补码一位乘：布斯公式法"><a href="#补码一位乘：布斯公式法" class="headerlink" title="补码一位乘：布斯公式法"></a>补码一位乘：布斯公式法</h1><p><strong>Note：</strong> 乘数最后一位补0。</p><ol><li>$Y_{i+1}-Y<em>i=0(Y</em>{i+1}Y_i=00$或$11)$，部分积加1,右移一位。</li><li>$Y_{i+1}-Y<em>i=1(Y</em>{i+1}Y_i=10)$，部分积加[X]的补码，右移一位。</li><li>$Y_{i+1}-Y<em>i=1(Y</em>{i+1}Y_i=01)$，部分积加[-X]的补码，右移一位。</li><li>最后一步$(i=n+1)$不移位。  </li></ol><p>累加n+1次（n为X和Y的小数位数），右移n次。</p><h1 id="原码一位除：加减交替法"><a href="#原码一位除：加减交替法" class="headerlink" title="原码一位除：加减交替法"></a>原码一位除：加减交替法</h1><p>定点除法运算有 <strong>恢复余数法</strong> 和 <strong>加减交替法</strong> ，在计算机中最常使用的是加减交替法，因为它的操作步数少，而且也不复杂。</p><ol><li>当求得的余数为负时，加上除数。</li><li>当求得的余数为正时，减去除数。</li><li>对定点小数除法要保证除数和被除数的绝对值小于1。</li><li>商的符号为两数字符号的异或。</li></ol><h1 id="浮点数的加减运算（分五个步骤）"><a href="#浮点数的加减运算（分五个步骤）" class="headerlink" title="浮点数的加减运算（分五个步骤）"></a>浮点数的加减运算（分五个步骤）</h1><ol><li>对阶</li><li>尾数加减</li><li>规格化</li><li>舍入</li><li>判溢出</li><li>得到结果</li></ol><h1 id="定点原码数、定点补码数的表示范围"><a href="#定点原码数、定点补码数的表示范围" class="headerlink" title="定点原码数、定点补码数的表示范围"></a>定点原码数、定点补码数的表示范围</h1><p>机器字长8位包含一位符号位<br>定点原码表示范围为$[-2^{7}+1, 2^7-1]$<br>定点补码表示范围为$[]$</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;十进制数、二进制数、十六进制数的相互转换&quot;&gt;&lt;a href=&quot;#十进制数、二进制数、十六进制数的相互转换&quot; class=&quot;headerlink&quot; title=&quot;十进制数、二进制数、十六进制数的相互转换&quot;&gt;&lt;/a&gt;十进制数、二进制数、十六进制数的相互转换&lt;/h1&gt;&lt;
      
    
    </summary>
    
      <category term="计算机组成原理" scheme="http://sunlanchang.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="计算机组成原理" scheme="http://sunlanchang.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>计算机组成原理系统概论</title>
    <link href="http://sunlanchang.github.io/2017/12/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/"/>
    <id>http://sunlanchang.github.io/2017/12/14/计算机组成原理系统概论/</id>
    <published>2017-12-14T10:30:28.000Z</published>
    <updated>2017-12-22T14:58:10.793Z</updated>
    
    <content type="html"><![CDATA[<h1 id="冯•诺依曼结构计算机的特点"><a href="#冯•诺依曼结构计算机的特点" class="headerlink" title="冯•诺依曼结构计算机的特点"></a>冯•诺依曼结构计算机的特点</h1><ol><li>计算机由运算器、控制器、存储器、输入设备、输出设备组成。</li><li>采用存储程序的方式，程序和数据放在同一个存储器中，并以二进制表示。</li><li>指令由操作码和地址码组成。</li><li>指令在存储器中按执行顺序排放，由指令计数器（即程序计数器PC）指明要执行的指令所在存储单元地址。</li><li>机器以运算器为中心，输入输出设备与存储器之间的数据传送都通过运算器。</li></ol><h1 id="计算机硬件系统的组成"><a href="#计算机硬件系统的组成" class="headerlink" title="计算机硬件系统的组成"></a>计算机硬件系统的组成</h1><p>计算机由运算器、控制器、存储器、输入设备、输出设备组成。  </p><ol><li>运算器是对数据进行处理的运算部件，一般进行算数运算和逻辑运算。</li><li>控制器实现程序的自动执行。</li><li>存储器用来存放程序和数据。</li><li>输入设备用来输入原始数据和处理这些数据的程序。</li><li>输出设备用来输出计算机的处理结果。</li></ol><h1 id="计算机语言：机器语言、汇编语言、高级语言，三种语言的特点"><a href="#计算机语言：机器语言、汇编语言、高级语言，三种语言的特点" class="headerlink" title="计算机语言：机器语言、汇编语言、高级语言，三种语言的特点"></a>计算机语言：机器语言、汇编语言、高级语言，三种语言的特点</h1><ol><li>机器语言是用二进制代码表示的计算机能直接识别和执行的一种机器指令的集合。</li><li>汇编语言是一种用助记符表示的仍然面向机器的计算机语言。</li><li>高级语言是与自然语言相近并为计算机所接受和执行的计算机语言。</li></ol><h1 id="计算机系统的构成：硬件系统和软件系统"><a href="#计算机系统的构成：硬件系统和软件系统" class="headerlink" title="计算机系统的构成：硬件系统和软件系统"></a>计算机系统的构成：硬件系统和软件系统</h1><p><strong>Note</strong></p><ol><li>常用三级时序系统：指令周期-机器周期-时钟周期</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;冯•诺依曼结构计算机的特点&quot;&gt;&lt;a href=&quot;#冯•诺依曼结构计算机的特点&quot; class=&quot;headerlink&quot; title=&quot;冯•诺依曼结构计算机的特点&quot;&gt;&lt;/a&gt;冯•诺依曼结构计算机的特点&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;计算机由运算器、控制器、存储器、输入设备
      
    
    </summary>
    
      <category term="计算机组成原理" scheme="http://sunlanchang.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="计算机组成原理" scheme="http://sunlanchang.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>数据定义</title>
    <link href="http://sunlanchang.github.io/2017/11/27/%E6%95%B0%E6%8D%AE%E5%AE%9A%E4%B9%89/"/>
    <id>http://sunlanchang.github.io/2017/11/27/数据定义/</id>
    <published>2017-11-27T07:42:36.000Z</published>
    <updated>2017-11-27T07:46:27.560Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>SQL功能分为一下四大部分：</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h1&gt;&lt;p&gt;SQL功能分为一下四大部分：&lt;/p&gt;

      
    
    </summary>
    
      <category term="数据库原理与应用" scheme="http://sunlanchang.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8/"/>
    
    
      <category term="数据库原理与应用" scheme="http://sunlanchang.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>图解寻址方式</title>
    <link href="http://sunlanchang.github.io/2017/11/21/%E5%9B%BE%E8%A7%A3%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F/"/>
    <id>http://sunlanchang.github.io/2017/11/21/图解寻址方式/</id>
    <published>2017-11-21T14:56:44.000Z</published>
    <updated>2017-11-22T02:38:25.708Z</updated>
    
    <content type="html"><![CDATA[<h1 id="直接寻址"><a href="#直接寻址" class="headerlink" title="直接寻址"></a>直接寻址</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/zhijiexunzhi.gif" alt="直接寻址" title="">                </div>                <div class="image-caption">直接寻址</div>            </figure>  <h1 id="间接寻址"><a href="#间接寻址" class="headerlink" title="间接寻址"></a>间接寻址</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/jianjiexunzhi.png" alt="存储器间接寻址" title="">                </div>                <div class="image-caption">存储器间接寻址</div>            </figure>  <figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/jicunqijianjiexunzhi.jpg" alt="寄存器间接寻址" title="">                </div>                <div class="image-caption">寄存器间接寻址</div>            </figure><h1 id="基址寻址"><a href="#基址寻址" class="headerlink" title="基址寻址"></a>基址寻址</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/jizhixunzhi.jpg" alt="基址寻址" title="">                </div>                <div class="image-caption">基址寻址</div>            </figure><h1 id="变址寻址"><a href="#变址寻址" class="headerlink" title="变址寻址"></a>变址寻址</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/bianzhixunzhi.jpg" alt="变址寻址" title="">                </div>                <div class="image-caption">变址寻址</div>            </figure><h1 id="立即数寻址"><a href="#立即数寻址" class="headerlink" title="立即数寻址"></a>立即数寻址</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/lijixunzhi.jpg" alt="立即数寻址" title="">                </div>                <div class="image-caption">立即数寻址</div>            </figure><h1 id="寄存器寻址"><a href="#寄存器寻址" class="headerlink" title="寄存器寻址"></a>寄存器寻址</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/jicunqixunzhi.jpg" alt="寄存器寻址" title="">                </div>                <div class="image-caption">寄存器寻址</div>            </figure><h1 id="相对寻址"><a href="#相对寻址" class="headerlink" title="相对寻址"></a>相对寻址</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/xiangduixunzhi.png" alt="相对寻址" title="">                </div>                <div class="image-caption">相对寻址</div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;直接寻址&quot;&gt;&lt;a href=&quot;#直接寻址&quot; class=&quot;headerlink&quot; title=&quot;直接寻址&quot;&gt;&lt;/a&gt;直接寻址&lt;/h1&gt;&lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lig
      
    
    </summary>
    
      <category term="计算机组成原理" scheme="http://sunlanchang.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="计算机组成原理" scheme="http://sunlanchang.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>数据查询</title>
    <link href="http://sunlanchang.github.io/2017/11/19/%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2/"/>
    <id>http://sunlanchang.github.io/2017/11/19/数据查询/</id>
    <published>2017-11-19T14:47:38.000Z</published>
    <updated>2017-11-27T07:42:09.689Z</updated>
    
    <content type="html"><![CDATA[<p>数据查询功能查询功能是SQL按的核心功能，是数据库用的最多的操作，查询语句是SQL语句比较复杂的语句。以下查询用到的三张表如下所示：<br><strong>Student表：</strong>  </p><table><thead><tr><th>Sno</th><th>Sname</th><th>Ssex</th><th>Sage</th><th>Sdept</th></tr></thead><tbody><tr><td>150752</td><td>孙兰昌</td><td>男</td><td>20</td><td>计算机系</td></tr><tr><td>150765</td><td>梁诗笛</td><td>女</td><td>19</td><td>计算机系</td></tr><tr><td>…</td><td>…</td><td>…</td><td>…</td><td>…</td></tr></tbody></table><p><strong>Course表：</strong>  </p><table><thead><tr><th style="text-align:center">Cno</th><th style="text-align:center">Cname</th><th style="text-align:center">Credit</th><th style="text-align:center">Semester</th></tr></thead><tbody><tr><td style="text-align:center">c01</td><td style="text-align:center">高等数学</td><td style="text-align:center">5</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">c02</td><td style="text-align:center">数据结构</td><td style="text-align:center">3</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">…</td><td style="text-align:center">…</td><td style="text-align:center">…</td><td style="text-align:center">…</td></tr></tbody></table><p><strong>SC表：</strong>  </p><table><thead><tr><th style="text-align:center">Sno</th><th style="text-align:center">Cno</th><th style="text-align:center">Grade</th></tr></thead><tbody><tr><td style="text-align:center">150752</td><td style="text-align:center">c01</td><td style="text-align:center">90</td></tr><tr><td style="text-align:center">150765</td><td style="text-align:center">c02</td><td style="text-align:center">88</td></tr><tr><td style="text-align:center">…</td><td style="text-align:center">…</td><td style="text-align:center">…</td></tr></tbody></table><h1 id="查询语句的基本结构"><a href="#查询语句的基本结构" class="headerlink" title="查询语句的基本结构"></a>查询语句的基本结构</h1><p>查询语句的基本结构可描述为：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> &lt;目标列名序列&gt;      <span class="comment">--需要哪些列</span></div><div class="line">  <span class="keyword">from</span> &lt;数据源&gt;           <span class="comment">--来自哪些表</span></div><div class="line">  [<span class="keyword">where</span> &lt;检索条件表达式&gt;] <span class="comment">--根据什么条件</span></div><div class="line">  [<span class="keyword">group</span> <span class="keyword">by</span> &lt;分组依据列&gt;]</div><div class="line">  [<span class="keyword">having</span> &lt;组提取条件&gt;]</div><div class="line">  [<span class="keyword">order</span> <span class="keyword">by</span> &lt;排序依旧列&gt;]</div></pre></td></tr></table></figure></p><h1 id="单表查询"><a href="#单表查询" class="headerlink" title="单表查询"></a>单表查询</h1><h2 id="distinct去重"><a href="#distinct去重" class="headerlink" title="distinct去重"></a><code>distinct</code>去重</h2><p>SQL语言中的<code>distinct</code>关键字可以去掉查询结果的重复行，<code>distinct</code>放在<code>select</code>的后边、目标列名的前边。例如：<br><code>select distinct Sno from SC</code></p><h2 id="not-in、-匹配、escape转义、order-by排序"><a href="#not-in、-匹配、escape转义、order-by排序" class="headerlink" title="[not] in、_%[]匹配、escape转义、order by排序"></a><code>[not] in</code>、<code>_%[]</code>匹配、<code>escape</code>转义、<code>order by</code>排序</h2><ol><li><strong>in确定集合</strong><br><code>in</code>确定某个集合，<code>not in</code>不在某个集合，例如：   <ul><li><code>select Sname, Ssex from Student  where Sdept in (&#39;计算机系&#39;, &#39;数学系&#39;)</code>此查询等价于  <code>select Sname, Ssex from Student where Sdept=&#39;计算机系&#39; or Sdept=&#39;数学系&#39;</code>  </li><li><code>select Sname, Ssex from Student where Sdept not in (&#39;计算机系&#39;, &#39;数学系&#39;)</code>此查询等价于  <code>select Sname, Ssex from Student where Sdept!=&#39;计算机系&#39; and Sdept!=&#39;数学系&#39;</code>  </li></ul></li><li><strong>字符串匹配</strong><br>一般形式为：<code>列名 [not] like &lt;匹配串&gt;</code><ol><li><code>_</code>：匹配任意一个字符</li><li><code>%</code>：匹配0个或多个字符</li><li><code>[]</code>：匹配<code>[]</code>中的任意一个字符。如<code>[aeiou]</code>匹配a、e、i、o、u中的任何一个。对于连续的字母匹配，例如<code>[abcd]</code>可以简写<code>[a-d]</code>。  </li><li><code>[^]</code>：不匹配[]中的任何一个字符。如<code>[^abc]</code>表示不匹配a、b、c。对于连续的字母可以简写例如<code>[^a-d]</code>。</li></ol></li><li><strong>escape转义字符匹配</strong><br>语法格式：<code>escape 转义字符</code><br>例如：  <code>where field like &#39;%30\%%&#39; escape &#39;\&#39;</code></li><li><strong>对查询结果进行排序</strong><br>排序语法格式： <code>order by &lt;列名&gt; [asc | desc]</code><br><code>asc</code>：升序排序，<code>desc</code>：降序排序。如果指定多个列排序，则按照列的先后顺序排序，即最前面的优先级最高。</li><li><strong>使用聚合函数汇总数据</strong><ul><li><code>count([distinct] &lt;列名&gt;)</code>：统计本列非空列值个数。</li><li><code>sum()  ave()  min()  max()</code>功能类似  </li></ul></li></ol><h2 id="group-by分组"><a href="#group-by分组" class="headerlink" title="group by分组"></a>group by分组</h2><p>语法：<code>group by [分组依据列] [having &lt;组约束条件&gt;]</code><br>SQL先执行<code>where</code>后执行<code>group by</code>再执行<code>having</code>，建议在所有分组之前进行的搜索条件放在<code>where</code>中，分组之后的条件搜索放在<code>having</code>中更为高效。<br><strong>Note：</strong><br>查询年龄小于20学生人数：<code>select Sdept, count(*) from Student where age &lt; 20 group by Sdept</code>，而不能写成：<code>select Sdept, count(*) from Student group by Sdept having Sage &lt; 20</code>，因为在分组之后只保留分组依据列以及聚合函数，因为执行到<code>having</code>时已经没有<code>Sage</code>列了。</p><h1 id="多表连接查询"><a href="#多表连接查询" class="headerlink" title="多表连接查询"></a>多表连接查询</h1><h2 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h2><p>使用内连接时，如果两个表的相关字段满足连接条件，则从两个表提取数据并组合成新的记录。<br>语法格式：<code>from table1 [inner] join table on &lt;连接条件&gt;</code><br>例如：<code>select * from studnet inner join SC on Studnet.Sno = SC.Sno</code></p><h2 id="自连接"><a href="#自连接" class="headerlink" title="自连接"></a>自连接</h2><p>在自连接时一定要有别名。<br>例如：查询与操作系统学分相同的课程的课程名和学分。<code>select C1.Cname, C2.Credit from Course C1 join Course C2 on C1.Credit = C2.Credit where C2.Cname = &#39;操作系统&#39;</code></p><h2 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h2><p>查找不满足条件的记录。<code>left</code>以左表为基础对右表进行筛选，<code>right</code>类似。<br>语法：<code>from table1 left | right [outer] join table2 on &lt;连接条件&gt;</code><br>例如：查询学生的选课情况，包括选了课程的学生和没有选课程的学生，列出学号、姓名、课程号和成绩。<code>select Studnet.Sno, Sname, Cno, Grade from Student left outer join SC on Student.Sno = SC.Sno</code></p><h1 id="使用TOP限制结果集"><a href="#使用TOP限制结果集" class="headerlink" title="使用TOP限制结果集"></a>使用TOP限制结果集</h1><p>语法：<code>top n [percent] [with ties]</code><br>一般与<code>order by</code>同时使用。<br>其中：  </p><ul><li>n为非负整数</li><li><code>top n</code>表示取查询的前n行数据</li><li><code>top n percent</code>：表示取查询结果的前n%行数据</li><li><code>with ties</code>：包括并列的结果<br>例如：查询年龄最大的三个学生的信息,包括并列的情况。<code>select top 3 with ties * from Student order by Sage desc</code><h1 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h1>SQL语言中，一个<code>select-from-where</code>语句称为一个查询块。一个查询块嵌入了另外一个<code>select</code>、<code>insert</code>、<code>update</code>或<code>delete</code>则称为子查询或内层查询。  <h2 id="集合测试"><a href="#集合测试" class="headerlink" title="集合测试"></a>集合测试</h2>语法：<code>where 表达式 [not] in (子查询)</code><br>例如：  </li></ul><ol><li>查询与小明同在一个系学习的学生。<code>select * from Student where Sdept in (select Sdept from Student where Sname=&#39;小明&#39;)</code>  </li><li>查询选了c02课程的学生。<code>select * from Student where Sno in (select Sno from SC where Cno=&#39;c02&#39;) and</code>，此查询也可以用多表连接查询实现：<code>select * from Student as S join SC on S.Sno==SC.Sno where Sdept=&#39;计算机系&#39; and Cno=&#39;c02&#39;</code>  <h2 id="比较测试"><a href="#比较测试" class="headerlink" title="比较测试"></a>比较测试</h2>语法：<code>where 表达式 比较运算符 (子查询)</code><br>其中比较运算符有：<code>= &lt;&gt; &lt; &gt; &lt;= &gt;=</code>。<br>例如：  </li></ol><ul><li>查询考试成绩高于平均成绩的学生：<code>select * from student from SC group by Sno having AVG(Grade) &gt; (select AVG(Grade) from SC)</code>。<blockquote><p>集合测试和比较测试都是先执行子查询，在执行外层查询，子查询只执行一次且不依赖于外层查询，这样的查询称为<strong>不相关子查询</strong>或<strong>嵌套子查询</strong>。  </p></blockquote></li></ul><h2 id="存在测试"><a href="#存在测试" class="headerlink" title="存在测试"></a>存在测试</h2><p>语法：<code>where [not] exists (子查询)</code>  </p><ol><li>存在测试先执行外层查询，后执行子查询；子层查询的次数由外层查询结果决定。</li><li>存在测试只返回真值或假值，所以在子查询中指定列名没有意义，通常用<code>select *</code>代替。<br>例如：查询选修了c01课程的学生：<code>select * from Student where exists (select * from SC where Sno = Student.Sno and Cno = &#39;c01&#39;)</code>  </li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;数据查询功能查询功能是SQL按的核心功能，是数据库用的最多的操作，查询语句是SQL语句比较复杂的语句。以下查询用到的三张表如下所示：&lt;br&gt;&lt;strong&gt;Student表：&lt;/strong&gt;  &lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Sno&lt;/th&gt;

      
    
    </summary>
    
      <category term="数据库原理与应用" scheme="http://sunlanchang.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8/"/>
    
    
      <category term="数据库原理与应用" scheme="http://sunlanchang.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>寻址方式之——相对寻址、堆栈寻址</title>
    <link href="http://sunlanchang.github.io/2017/11/18/%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%E4%B9%8B%E2%80%94%E2%80%94%E7%9B%B8%E5%AF%B9%E5%AF%BB%E5%9D%80%E3%80%81%E5%A0%86%E6%A0%88%E5%AF%BB%E5%9D%80/"/>
    <id>http://sunlanchang.github.io/2017/11/18/寻址方式之——相对寻址、堆栈寻址/</id>
    <published>2017-11-18T15:28:21.000Z</published>
    <updated>2017-11-22T02:38:17.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="相对寻址"><a href="#相对寻址" class="headerlink" title="相对寻址"></a>相对寻址</h1><ul><li>与基址变址寻址方式相类似，相对寻址以程序计数器PC的当前值（R15中的值）为基地址，指令中的地址标号作为偏移量，将两者相加后得到操作数的有效地址。</li><li>相对寻址主要用于转移指令，执行本条命令后，转移到（PC）+ Disp，（PC）为程序计数器的内容。</li><li>特点：  <ol><li>转移地址不是固定的，它随着PC值的变化而变化，并且总是与PC相差一个固定的值disp，因此无论程序转入存储器的任何地方，均能正确运行，对浮动程序很适用。</li><li>位移量可正、可负，通常用补码表示。<br><img src="/images/xiangduixunzhi.png" alt="相对寻址"><h1 id="堆栈寻址"><a href="#堆栈寻址" class="headerlink" title="堆栈寻址"></a>堆栈寻址</h1>堆栈是一种数据结构，按先进后出（First In Last Out，FILO）的方式工作，使用堆栈指针（Stack Pointer, SP）指示当前的操作位置，堆栈指针总是指向栈顶。<br>根据堆栈的生成方式不同，可以把堆栈分为递增堆栈和递减堆栈两种类型。</li></ol></li></ul><ul><li>递增堆栈：向堆栈写入数据时，堆栈由低地址向高地址生长。</li><li>递减堆栈：向堆栈写入数据时，堆栈由高地址向低地址生长。<br>同时，根据堆栈指针（SP）指向的位置，又可以把堆栈分为满堆栈（Full Stack）和空堆栈（Empty Stack）两种类型。</li><li>满堆栈（Full Stack）：堆栈指针指向最后压入堆栈的数据。满堆栈在向堆栈存放数据时的操作是先移动SP指针，然后存放数据。在从堆栈取数据时，先取出数据，随后移动SP指针。这样保证了SP一直指向有效的数据。</li><li>空堆栈（Empty Stack）：堆栈指针SP指向下一个将要放入数据的空位置。空堆栈在向堆栈存放数据时的操作是先放数据，然后移动SP指针。在从堆栈取数据时，是先移动指针，再取数据。这种操作方式保证了堆栈指针一直指向一个空地址（没有有效数据的地址）。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;相对寻址&quot;&gt;&lt;a href=&quot;#相对寻址&quot; class=&quot;headerlink&quot; title=&quot;相对寻址&quot;&gt;&lt;/a&gt;相对寻址&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;与基址变址寻址方式相类似，相对寻址以程序计数器PC的当前值（R15中的值）为基地址，指令中的地址标号作为偏移量，
      
    
    </summary>
    
      <category term="计算机组成原理" scheme="http://sunlanchang.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="计算机组成原理" scheme="http://sunlanchang.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>寻址方式之——基址寻址、变址寻址</title>
    <link href="http://sunlanchang.github.io/2017/11/17/%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%E4%B9%8B%E2%80%94%E2%80%94%E5%9F%BA%E5%9D%80%E5%AF%BB%E5%9D%80%E3%80%81%E5%8F%98%E5%9D%80%E5%AF%BB%E5%9D%80/"/>
    <id>http://sunlanchang.github.io/2017/11/17/寻址方式之——基址寻址、变址寻址/</id>
    <published>2017-11-17T15:17:59.000Z</published>
    <updated>2017-11-22T02:37:12.496Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基址寻址"><a href="#基址寻址" class="headerlink" title="基址寻址"></a>基址寻址</h1><ol><li>在计算机设置一个专用的基址寄存器，或者由指令指定一个通用寄存器为基址寄存器。操作数的地址由基址寄存器的内容和指令的地址码A相加得到，这种情况下地址码A常被成为位移量（disp）。</li><li>当存储器容量比较大，有指令的地址码部分直接给出的地址不能直接访问到存储器的单元时，通常将存储器分成若干段，段的首地址存放在基址寄存器中，段内的位移量由指令给出。存储器的实际地址就等于基址寄存器和段内位移量相加。</li><li>基址寻址主要用来解决程序在存储器中的定位和扩大寻址空间等问题。通常基址寄存器只能由系统程序设定，由特权指令执行，一般用户不能够修改，保证了系统的安全性。<br><img src="/images/jizhixunzhi.jpg" alt="基址寻址"><h1 id="变址寻址"><a href="#变址寻址" class="headerlink" title="变址寻址"></a>变址寻址</h1>指令地址码给出地址A和指定的变址寄存器R,将A和R的内容相加就是操作数的地址。常利用变址操作与循环执行程序的方法对数组进行运算。<br><img src="/images/bianzhixunzhi.jpg" alt="变址寻址"><h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1></li></ol><ul><li>基址寻址主要用于为程序或数据分配存储空间，故基址寄存器的内容通常由操作系统或管理程序确定，在程序运行过程中，值是不可变的，而指令字中的地址码是可变的。</li><li>变址寻址中，变址寄存器的内容是用户自己设定的，在程序运行过程中是可变的，而指令字中的地址码是不可变的。编制寻址主要用于处理数组等问题，并且特别适合编制循环程序。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基址寻址&quot;&gt;&lt;a href=&quot;#基址寻址&quot; class=&quot;headerlink&quot; title=&quot;基址寻址&quot;&gt;&lt;/a&gt;基址寻址&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;在计算机设置一个专用的基址寄存器，或者由指令指定一个通用寄存器为基址寄存器。操作数的地址由基址寄存器的内容和指令
      
    
    </summary>
    
      <category term="计算机组成原理" scheme="http://sunlanchang.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="计算机组成原理" scheme="http://sunlanchang.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>寻址方式之——直接寻址、间接寻址</title>
    <link href="http://sunlanchang.github.io/2017/11/17/%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%E4%B9%8B%E2%80%94%E2%80%94%E7%9B%B4%E6%8E%A5%E5%AF%BB%E5%9D%80%E3%80%81%E9%97%B4%E6%8E%A5%E5%AF%BB%E5%9D%80/"/>
    <id>http://sunlanchang.github.io/2017/11/17/寻址方式之——直接寻址、间接寻址/</id>
    <published>2017-11-17T14:31:12.000Z</published>
    <updated>2017-11-22T02:37:55.588Z</updated>
    
    <content type="html"><![CDATA[<h1 id="直接寻址"><a href="#直接寻址" class="headerlink" title="直接寻址"></a>直接寻址</h1><p>指令的地址码部分给出操作数在存储器中的地址，比如给出一个操作数的字段为3位，则寻址方式为有8种。如下图<br><img src="/images/zhijiexunzhi.gif" alt="直接寻址"><br>注意：立即寻址方式和直接寻址方式的书写格式的不同，直接寻址的地址要写在括号“[”，“]”内。在程序中，直接地址通常用内存变量名来表示，如：MOV BX, VARW，其中，VARW是内存字变量。<br>试比较下列指令中源操作数的寻址方式(VARW是内存字变量)：<br><figure class="highlight arm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">MOV　</span>AX, <span class="number">1234</span>H<span class="comment">;    MOV　AX, [1234H] ;前者是立即寻址，后者是直接寻址</span></div><div class="line"><span class="keyword">MOV　</span>AX, VARW<span class="comment">;     MOV　AX, [VARW] ;两者是等效的，均为直接寻址</span></div></pre></td></tr></table></figure></p><h1 id="间接寻址"><a href="#间接寻址" class="headerlink" title="间接寻址"></a>间接寻址</h1><p>在寻址是，有时根据指令的地址码所取出的内容既不是操作数，也不是下一条要执行的指令，而是操作数的地址或指令的地址，这种方式成为间接寻址。根据地址码指的是寄存器地址还是存储器地址，间接寻址又可以分为寄存器间接寻址和存储器间接寻址两种方式。间接寻址有一次间接寻址和间接寻址两种情况，大多数计算机只允许一次间接寻址。对于存储器一次间接寻址情况，许访问两次存储器才能取得数据，第一次从存储器读出操作数地址，第二次读出操作数。如下图所示<br><img src="/images/jianjiexunzhi.png" alt="存储器间接寻址"><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/jicunqijianjiexunzhi.jpg" alt="寄存器间接寻址" title="">                </div>                <div class="image-caption">寄存器间接寻址</div>            </figure>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;直接寻址&quot;&gt;&lt;a href=&quot;#直接寻址&quot; class=&quot;headerlink&quot; title=&quot;直接寻址&quot;&gt;&lt;/a&gt;直接寻址&lt;/h1&gt;&lt;p&gt;指令的地址码部分给出操作数在存储器中的地址，比如给出一个操作数的字段为3位，则寻址方式为有8种。如下图&lt;br&gt;&lt;img sr
      
    
    </summary>
    
      <category term="计算机组成原理" scheme="http://sunlanchang.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="计算机组成原理" scheme="http://sunlanchang.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>IP地址、IP子网、CIDR</title>
    <link href="http://sunlanchang.github.io/2017/11/14/IP%E5%9C%B0%E5%9D%80%E3%80%81IP%E5%AD%90%E7%BD%91%E3%80%81CIDR/"/>
    <id>http://sunlanchang.github.io/2017/11/14/IP地址、IP子网、CIDR/</id>
    <published>2017-11-14T14:11:22.000Z</published>
    <updated>2017-11-17T14:23:16.102Z</updated>
    
    <content type="html"><![CDATA[<h1 id="标准分类的IP地址"><a href="#标准分类的IP地址" class="headerlink" title="标准分类的IP地址"></a>标准分类的IP地址</h1><p>先来一张图便于查阅，如下图：<br><img src="/images/biaozhunfenleiIPdizhi.png" alt="标准分类的IP地址"><br>在互联网络中，需要为每个主机和路由器等设备分配一个在全世界范围内唯一的IP地址，格式为<code>{&lt;网络号&gt;，&lt;主机号&gt;}</code>IP地址的编址方法共经历了以下五个阶段：</p><ol><li>分类的IP地址。  </li><li>划分子网。  </li><li>构成超网。</li><li>网络地址转换。</li><li>IPv6。<br>如下图所示：<br><img src="/images/IPyanbianguocheng.png" alt="">  <h1 id="IP子网的划分"><a href="#IP子网的划分" class="headerlink" title="IP子网的划分"></a>IP子网的划分</h1>格式为：<code>{&lt;网络号&gt;，&lt;子网号&gt;，&lt;主机号&gt;}</code></li></ol><ul><li>A类地址的默认子网掩码：255.0.0.0  </li><li>B类地址的默认子网掩码：255.255.0.0  </li><li>C类地址的默认子网掩码：255.255.255.0<br><img src="/images/ziwangyanma.png" alt=""><br><strong>例如一个B类IP为202.194.0.0均分给6个部门使用，求子网掩码、网络号、子网号、主机号？</strong>  </li></ul><ol><li>从<code>202.194.0.0</code>这个地址可以知道（网络号是<code>202.194</code>，则主机号是16位）</li><li>因为2的3次方为8，所以需要从主机号借3位作子网号才能保证分出6子网，剩下的13位作为主机号，每个子网可容纳最大主机数213 - 2 = 8190个，减去网络地址和广播地址。</li><li><p>子网号和主机号  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">202.194.0.0（子网号000）202.194.0.1~202.194.0.254（主机号）202.194.0.255（广播地址）</div><div class="line">202.194.32.0（子网号001）202.194.32.1~202.194.32.254（主机号）202.194.32.255（广播地址）</div><div class="line">202.194.64.0（子网号010）202.194.64.1~202.194.64.254（主机号）202.194.64.255（广播地址）</div><div class="line">202.194.96.0（子网号011）202.194.96.1~202.194.96.254（主机号）202.194.96.255（广播地址）</div><div class="line">202.194.128.0（子网号100）202.194.128.1~202.194.128.254（主机号）202.194.128.255（广播地址）</div><div class="line">202.194.160.0（子网号101）202.194.160.1~202.194.160.254（主机号）202.194.160.255（广播地址）</div><div class="line">202.194.192.0（子网号110）202.194.192.1~202.194.192.254（主机号）202.194.192.255（广播地址）</div><div class="line">202.194.224.0（子网号111）202.194.224.1~202.194.224.254（主机号）202.194.224.255（广播地址）</div></pre></td></tr></table></figure></li><li><p>主机号借了3位，子网掩码为<code>11111111.11111111.11100000.00000000</code>即<code>255.255.224.0</code></p><h1 id="3-无分类编址CIDR"><a href="#3-无分类编址CIDR" class="headerlink" title="3.无分类编址CIDR"></a>3.无分类编址CIDR</h1><p>格式为：<code>{&lt;网络前缀&gt;，&lt;主机号&gt;}</code><br>CIDR最主要有两个以下特点：  </p></li></ol><ul><li>消除传统的A，B，C地址和划分子网的概念，更有效的分配IPv4的地址空间，CIDR使IP地址又回到无分类的两级编码。记法：IP地址：：={&lt;&lt;网络前缀&gt;，&lt;&lt;主机号&gt;}。  </li><li>CIDR还使用“斜线记法”即在IP地址后面加上“/”然后写网络前缀所占的位数。CIDR把网络前缀都相同的连续IP地址组成一个“CIDR地址块”，即强化路由聚合（构成超网）。<br><strong>例如<code>202.194.20.138/19</code>，此IP中前19位为网络前缀，后13位为主机号。</strong>  </li></ul><ol><li><code>202.194.20.138/19</code>用二进制表示为：<br><code>11001010  11000010  00010100  1000101</code></li><li>该地址所在CIDR地址块中最小的地址为<br><code>11001010  11000010  00000000  00000000</code>，即<code>202.194.0.0</code></li><li>该地址所在CIDR地址块中最大的地址为：<br><code>11001010  11000010  00011111  11111111</code>，即<code>202.194.31.255</code></li><li>该地址块中共有213=8192个地址</li><li><code>/19</code>对应的子网掩码为<code>11111111.11111111.11100000.00000000</code>，即<code>255.255.224.0</code></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;标准分类的IP地址&quot;&gt;&lt;a href=&quot;#标准分类的IP地址&quot; class=&quot;headerlink&quot; title=&quot;标准分类的IP地址&quot;&gt;&lt;/a&gt;标准分类的IP地址&lt;/h1&gt;&lt;p&gt;先来一张图便于查阅，如下图：&lt;br&gt;&lt;img src=&quot;/images/biaozh
      
    
    </summary>
    
      <category term="计算机网络" scheme="http://sunlanchang.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="http://sunlanchang.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
</feed>
