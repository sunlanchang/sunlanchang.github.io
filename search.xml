<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[图解寻址方式]]></title>
    <url>%2F2017%2F11%2F21%2F%E5%9B%BE%E8%A7%A3%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[直接寻址 直接寻址 间接寻址 存储器间接寻址 寄存器间接寻址 基址寻址 基址寻址 变址寻址 变址寻址 立即数寻址 立即数寻址 寄存器寻址 寄存器寻址 相对寻址 相对寻址]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库查询]]></title>
    <url>%2F2017%2F11%2F19%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[数据查询功能查询功能是SQL按的核心功能，是数据库用的最多的操作，查询语句是SQL语句比较复杂的语句。以下查询用到的三张表如下所示：Student表： Sno Sname Ssex Sage Sdept 150752 孙兰昌 男 20 计算机系 150765 梁诗笛 女 19 计算机系 … … … … … Course表： Cno Cname Credit Semester c01 高等数学 5 1 c02 数据结构 3 2 … … … … SC表： Sno Cno Grade 150752 c01 90 150765 c02 88 … … … 查询语句的基本结构查询语句的基本结构可描述为：123456select &lt;目标列名序列&gt; --需要哪些列 from &lt;数据源&gt; --来自哪些表 [where &lt;检索条件表达式&gt;] --根据什么条件 [group by &lt;分组依据列&gt;] [having &lt;组提取条件&gt;] [order by &lt;排序依旧列&gt;] 单表查询distinct去重SQL语言中的distinct关键字可以去掉查询结果的重复行，distinct放在select的后边、目标列名的前边。例如：select distinct Sno from SC [not] in、_%[]匹配、escape转义、order by排序 in确定集合in确定某个集合，not in不在某个集合，例如： 12select Sname, Ssex from Student where Sdept in ('计算机系', '数学系') 此查询等价于12select Sname, Ssex from Student where Sdept='计算机系' or Sdept='数学系' 12select Sname, Ssex from Student where Sdept not in ('计算机系', '数学系') 此查询等价于12select Sname, Ssex from Student where Sdept!='计算机系' and Sdept!='数学系' 字符串匹配一般形式为：列名 [not] like &lt;匹配串&gt; _：匹配任意一个字符 %：匹配0个或多个字符 []：匹配[]中的任意一个字符。如[aeiou]匹配a、e、i、o、u中的任何一个。对于连续的字母匹配，例如[abcd]可以简写[a-d]。 [^]：不匹配[]中的任何一个字符。如[^abc]表示不匹配a、b、c。对于连续的字母可以简写例如[^a-d]。 escape转义字符匹配语法格式：escape 转义字符例如： 1where field like '%30\%%' escape '\' 对查询结果进行排序排序语法格式： order by &lt;列名&gt; [asc | desc]asc：升序排序，desc：降序排序。如果指定多个列排序，则按照列的先后顺序排序，即最前面的优先级最高。 使用聚合函数汇总数据 count([distinct] &lt;列名&gt;)：统计本列非空列值个数。 sum() ave() min() max()功能类似多表连接查询使用TOP限制结果集子查询]]></content>
      <categories>
        <category>数据库原理与应用</category>
      </categories>
      <tags>
        <tag>数据库原理与应用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[寻址方式之——相对寻址、堆栈寻址]]></title>
    <url>%2F2017%2F11%2F18%2F%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%E4%B9%8B%E2%80%94%E2%80%94%E7%9B%B8%E5%AF%B9%E5%AF%BB%E5%9D%80%E3%80%81%E5%A0%86%E6%A0%88%E5%AF%BB%E5%9D%80%2F</url>
    <content type="text"><![CDATA[相对寻址 与基址变址寻址方式相类似，相对寻址以程序计数器PC的当前值（R15中的值）为基地址，指令中的地址标号作为偏移量，将两者相加后得到操作数的有效地址。 相对寻址主要用于转移指令，执行本条命令后，转移到（PC）+ Disp，（PC）为程序计数器的内容。 特点： 转移地址不是固定的，它随着PC值的变化而变化，并且总是与PC相差一个固定的值disp，因此无论程序转入存储器的任何地方，均能正确运行，对浮动程序很适用。 位移量可正、可负，通常用补码表示。堆栈寻址堆栈是一种数据结构，按先进后出（First In Last Out，FILO）的方式工作，使用堆栈指针（Stack Pointer, SP）指示当前的操作位置，堆栈指针总是指向栈顶。根据堆栈的生成方式不同，可以把堆栈分为递增堆栈和递减堆栈两种类型。 递增堆栈：向堆栈写入数据时，堆栈由低地址向高地址生长。 递减堆栈：向堆栈写入数据时，堆栈由高地址向低地址生长。同时，根据堆栈指针（SP）指向的位置，又可以把堆栈分为满堆栈（Full Stack）和空堆栈（Empty Stack）两种类型。 满堆栈（Full Stack）：堆栈指针指向最后压入堆栈的数据。满堆栈在向堆栈存放数据时的操作是先移动SP指针，然后存放数据。在从堆栈取数据时，先取出数据，随后移动SP指针。这样保证了SP一直指向有效的数据。 空堆栈（Empty Stack）：堆栈指针SP指向下一个将要放入数据的空位置。空堆栈在向堆栈存放数据时的操作是先放数据，然后移动SP指针。在从堆栈取数据时，是先移动指针，再取数据。这种操作方式保证了堆栈指针一直指向一个空地址（没有有效数据的地址）。]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[寻址方式之——基址寻址、变址寻址]]></title>
    <url>%2F2017%2F11%2F17%2F%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%E4%B9%8B%E2%80%94%E2%80%94%E5%9F%BA%E5%9D%80%E5%AF%BB%E5%9D%80%E3%80%81%E5%8F%98%E5%9D%80%E5%AF%BB%E5%9D%80%2F</url>
    <content type="text"><![CDATA[基址寻址 在计算机设置一个专用的基址寄存器，或者由指令指定一个通用寄存器为基址寄存器。操作数的地址由基址寄存器的内容和指令的地址码A相加得到，这种情况下地址码A常被成为位移量（disp）。 当存储器容量比较大，有指令的地址码部分直接给出的地址不能直接访问到存储器的单元时，通常将存储器分成若干段，段的首地址存放在基址寄存器中，段内的位移量由指令给出。存储器的实际地址就等于基址寄存器和段内位移量相加。 基址寻址主要用来解决程序在存储器中的定位和扩大寻址空间等问题。通常基址寄存器只能由系统程序设定，由特权指令执行，一般用户不能够修改，保证了系统的安全性。变址寻址指令地址码给出地址A和指定的变址寄存器R,将A和R的内容相加就是操作数的地址。常利用变址操作与循环执行程序的方法对数组进行运算。区别 基址寻址主要用于为程序或数据分配存储空间，故基址寄存器的内容通常由操作系统或管理程序确定，在程序运行过程中，值是不可变的，而指令字中的地址码是可变的。 变址寻址中，变址寄存器的内容是用户自己设定的，在程序运行过程中是可变的，而指令字中的地址码是不可变的。编制寻址主要用于处理数组等问题，并且特别适合编制循环程序。]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[寻址方式之——直接寻址、间接寻址]]></title>
    <url>%2F2017%2F11%2F17%2F%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%E4%B9%8B%E2%80%94%E2%80%94%E7%9B%B4%E6%8E%A5%E5%AF%BB%E5%9D%80%E3%80%81%E9%97%B4%E6%8E%A5%E5%AF%BB%E5%9D%80%2F</url>
    <content type="text"><![CDATA[直接寻址指令的地址码部分给出操作数在存储器中的地址，比如给出一个操作数的字段为3位，则寻址方式为有8种。如下图注意：立即寻址方式和直接寻址方式的书写格式的不同，直接寻址的地址要写在括号“[”，“]”内。在程序中，直接地址通常用内存变量名来表示，如：MOV BX, VARW，其中，VARW是内存字变量。试比较下列指令中源操作数的寻址方式(VARW是内存字变量)：12MOV AX, 1234H; MOV AX, [1234H] ;前者是立即寻址，后者是直接寻址MOV AX, VARW; MOV AX, [VARW] ;两者是等效的，均为直接寻址 间接寻址在寻址是，有时根据指令的地址码所取出的内容既不是操作数，也不是下一条要执行的指令，而是操作数的地址或指令的地址，这种方式成为间接寻址。根据地址码指的是寄存器地址还是存储器地址，间接寻址又可以分为寄存器间接寻址和存储器间接寻址两种方式。间接寻址有一次间接寻址和间接寻址两种情况，大多数计算机只允许一次间接寻址。对于存储器一次间接寻址情况，许访问两次存储器才能取得数据，第一次从存储器读出操作数地址，第二次读出操作数。如下图所示 寄存器间接寻址]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IP地址、IP子网、CIDR]]></title>
    <url>%2F2017%2F11%2F14%2FIP%E5%9C%B0%E5%9D%80%E3%80%81IP%E5%AD%90%E7%BD%91%E3%80%81CIDR%2F</url>
    <content type="text"><![CDATA[标准分类的IP地址先来一张图便于查阅，如下图：在互联网络中，需要为每个主机和路由器等设备分配一个在全世界范围内唯一的IP地址，格式为{&lt;网络号&gt;，&lt;主机号&gt;}IP地址的编址方法共经历了以下五个阶段： 分类的IP地址。 划分子网。 构成超网。 网络地址转换。 IPv6。如下图所示： IP子网的划分格式为：{&lt;网络号&gt;，&lt;子网号&gt;，&lt;主机号&gt;} A类地址的默认子网掩码：255.0.0.0 B类地址的默认子网掩码：255.255.0.0 C类地址的默认子网掩码：255.255.255.0例如一个B类IP为202.194.0.0均分给6个部门使用，求子网掩码、网络号、子网号、主机号？ 从202.194.0.0这个地址可以知道（网络号是202.194，则主机号是16位） 因为2的3次方为8，所以需要从主机号借3位作子网号才能保证分出6子网，剩下的13位作为主机号，每个子网可容纳最大主机数213 - 2 = 8190个，减去网络地址和广播地址。 子网号和主机号 12345678202.194.0.0（子网号000）202.194.0.1~202.194.0.254（主机号）202.194.0.255（广播地址）202.194.32.0（子网号001）202.194.32.1~202.194.32.254（主机号）202.194.32.255（广播地址）202.194.64.0（子网号010）202.194.64.1~202.194.64.254（主机号）202.194.64.255（广播地址）202.194.96.0（子网号011）202.194.96.1~202.194.96.254（主机号）202.194.96.255（广播地址）202.194.128.0（子网号100）202.194.128.1~202.194.128.254（主机号）202.194.128.255（广播地址）202.194.160.0（子网号101）202.194.160.1~202.194.160.254（主机号）202.194.160.255（广播地址）202.194.192.0（子网号110）202.194.192.1~202.194.192.254（主机号）202.194.192.255（广播地址）202.194.224.0（子网号111）202.194.224.1~202.194.224.254（主机号）202.194.224.255（广播地址） 主机号借了3位，子网掩码为11111111.11111111.11100000.00000000即255.255.224.0 3.无分类编址CIDR格式为：{&lt;网络前缀&gt;，&lt;主机号&gt;}CIDR最主要有两个以下特点： 消除传统的A，B，C地址和划分子网的概念，更有效的分配IPv4的地址空间，CIDR使IP地址又回到无分类的两级编码。记法：IP地址：：={&lt;&lt;网络前缀&gt;，&lt;&lt;主机号&gt;}。 CIDR还使用“斜线记法”即在IP地址后面加上“/”然后写网络前缀所占的位数。CIDR把网络前缀都相同的连续IP地址组成一个“CIDR地址块”，即强化路由聚合（构成超网）。例如202.194.20.138/19，此IP中前19位为网络前缀，后13位为主机号。 202.194.20.138/19用二进制表示为：11001010 11000010 00010100 1000101 该地址所在CIDR地址块中最小的地址为11001010 11000010 00000000 00000000，即202.194.0.0 该地址所在CIDR地址块中最大的地址为：11001010 11000010 00011111 11111111，即202.194.31.255 该地址块中共有213=8192个地址 /19对应的子网掩码为11111111.11111111.11100000.00000000，即255.255.224.0]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[寻址方式之——立即数寻址、寄存器寻址]]></title>
    <url>%2F2017%2F11%2F14%2F%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%E2%80%94%E2%80%94%E7%AB%8B%E5%8D%B3%E6%95%B0%E5%AF%BB%E5%9D%80%E3%80%81%E5%AF%84%E5%AD%98%E5%99%A8%E5%AF%BB%E5%9D%80%2F</url>
    <content type="text"><![CDATA[立即数寻址所需的操作数由指令直接给出，就称为立即数（或直接数）寻址方式。这种方式的特点是：取指令时，操作码和操作数同时被取出，减少了访存次数，提高了指令的执行速度。但是由于这一操作数是指令的一部分，不能修改，所以这种方式只能适用操作数固定的情况，并且操作数的位数有限。通常用于给某一寄存器单元赋初值或者提供一个常数，例如C语言里int a = 1，运用到了立即数寻址。立即数可以是8位、16位或32位，该数值紧跟在操作码之后。如果立即数为16位或32位，那么，它将按“高高低低”的原则进行存储。例如：123MOV AH, 80HADD AX, 1234HMOV ECX, 123456H 以上指令中的第二操作数都是立即数，在汇编语言中规定：立即数不能作为指令中的第一操作数，该规定与高级语言中“赋值语句的左边不能是常量”的规定相一致。立即数寻址方式通常用于对通用寄存器或内存单元赋初值。图是指令”MOV AX, 4576H”存储形式和执行示意图。将4576H数据送入AX通用寄存器，类似于赋值语句。 寄存器寻址计算机的中央处理器一般设置有一定数量的通用寄存器，用来存放操作数，操作数的地址或中间结果。假如指令地址码部分给出某一通用寄存器地址即给出地址码A，而且所需的操作数就在这一寄存器中，则称为寄存器寻址。通用寄存器数量一般在几个到几十个之间，例如x86架构CPU有4个数据寄存器(EAX、EBX、ECX和EDX)，MIPS架构CPU有32个通用寄存器（$0-$31），ARM架构CPU有16个32位的寄存器（r0-r15）。从寄存器中存取数据比从存储器中存取数据快得多，所以这种寻址方式可以缩短指令长度，节省存储空间，提高指令的执行速度。 速度的比较按照离CPU由近到远的顺序依次是CPU寄存器、Cache、内存、硬盘，越靠近CPU的存储器容量越小但访问速度越快，下图给出了各种存储器的容量和访问速度的典型值。参考： http://blog.csdn.net/zlzlei/article/details/7790363http://blog.csdn.net/huangxb_csu/article/details/5976561http://blog.csdn.net/gujing001/article/details/8476685http://www.cnblogs.com/onroad/archive/2009/07/13/1522673.html]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu使用蓝灯无限流量]]></title>
    <url>%2F2017%2F11%2F03%2FUbuntu%E4%BD%BF%E7%94%A8%E8%93%9D%E7%81%AF%E6%97%A0%E9%99%90%E6%B5%81%E9%87%8F%2F</url>
    <content type="text"><![CDATA[lantern因为蓝灯3是通过用户的 MAC 地址来判断用户是否使用完免费高速流量。这里修改 MAC 地址的具体步骤如下： 通过 ifconfig 查看网卡设备，这里是enp2s0，有些地方是 eth0，以下统称 net_card 。 关闭网卡设备 sudo /sbin/ifconfig net_card down 修改 MAC 地址 sudo /sbin/ifconfig net_card hw ether 00:AA:BB:CC:DD:EE (要修改的MAC地址) 重新启用网卡 sudo /sbin/ifconfig net_card up 这是临时性修改MAC地址的方法，系统重启之后就会失效。不过这也比较符合我们的需求，一个MAC地址的免费高速流量用完之后就换另一个地址。]]></content>
      <categories>
        <category>Other</category>
      </categories>
      <tags>
        <tag>Other</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[校园网自动登录脚本]]></title>
    <url>%2F2017%2F10%2F31%2F%E6%A0%A1%E5%9B%AD%E7%BD%91%E8%87%AA%E5%8A%A8%E7%99%BB%E5%BD%95%E8%84%9A%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[校园网自动登录脚本环境 python 2.7或python 3.5均可用，脚本外部依赖requests库，请在运行脚本前pip3或者pip安装requests。 python 2.7运行时务必加上下面一行代码，指定编码为utf8，python3可以忽略。 具体实现 指定编码方式为utf8。 12# coding: utf-8import requests 通过Chrome浏览器得知校园网登录地址，注意直接在浏览器输入的地址不一定是发送数据的地址，我学校是下面这个。 1url = 'http://210.31.32.126/cgi-bin/do_login' 浏览器头信息用来伪装浏览器 123456789101112131415161718def login(): postdata = &#123;'username': '你的校园网账号', 'password': '&#123;TEXT&#125;你的密码', 'drop': '0', 'type': '1', 'n': '100'&#125; headers = &#123;'Accept': '*/*', 'Accept-Encoding': 'gzip, deflate', 'Accept-Language': 'zh-CN,zh;q=0.8', 'Connection': 'keep-alive', 'Content-Length': '65', 'Content-Type': 'application/x-www-form-urlencoded', 'Cookie': 'PHPSESSID=a70fr8pfvhhtt329qvb21p7ka6', 'Host': '210.31.32.126', 'Origin': 'http://210.31.32.126', 'Referer': 'http://210.31.32.126/', 'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/61.0.3163.91 Safari/537.36'&#125; requests.post(url, data=postdata) 查看连接的是否是校园网，以及是否连上网1234567891011121314def is_connect_edu(): status_code = requests.get(url).status_code if status_code == 200: return True else: return Falsedef is_connect_web(): r = requests.get("http://www.baidu.com").text if r.find('210.31.32.126') != -1: return False else: return True 直到校园网连接上为止123456789while True: if is_connect_edu(): # 是否连接上校园网 if not is_connect_web(): # 是否连接上外网 login() if requests.get('http://www.baidu.com').status_code==200: print('Already connected Internet') else: print('Not connected Internet') break Ubuntu开机自动启动登录root权限修改/etc/rc.local文件在exit 0上一行加上python3 xiaoyuanwang.py即可实现开机启动此脚本 获取源码点击获取源码]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[极限的保号性、无穷小运算法则、七种未定型]]></title>
    <url>%2F2017%2F10%2F31%2F%E6%9E%81%E9%99%90%E7%9A%84%E4%BF%9D%E5%8F%B7%E6%80%A7%E3%80%81%E6%97%A0%E7%A9%B7%E5%B0%8F%E8%BF%90%E7%AE%97%E6%B3%95%E5%88%99%E3%80%81%E4%B8%83%E7%A7%8D%E6%9C%AA%E5%AE%9A%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[极限的保号性、运算法则、七种未定型极限的保号性 $\lim\limits_{x\to a}f(x)=A(A\neq0)$则$f(x)$与$A$同号。 $f(x)&gt;0$，$\lim\limits_{x\to a}f(x)=A$则$A\geq0$。无穷小运算 相同的运算法则 $o(x^m)\pm o(x^n)=o(x^n)$其中$(m&gt;n)$ $x^mo(x^n)=o(x^{m+n})$ $\frac{o(x^m)}{o(x^n)}=0$其中$(m&gt;n)$ $ko(x^n)=o(x^n)$ 注意无穷大加减运算与无穷小相反。 $o(x^m)\pm o(x^n)=o(x^m)$其中$(m&gt;n)$ 七种未定型的极限1. 第一类：$\frac{0}{0}$，$\frac{\infty}{\infty}$，$0\cdot\infty$ 洛必达法则 等价无穷小代换 泰勒展开式 消去去穷大（做大题用） 抓大头（做选择、填空或者检验大题答案用）2. 第二类：$\infty^0$，$0^0$，$1^*$(1的任意次幂) $1^*$常用${f(x)}^{g(x)}=e^{(f(x)-1)g(x)}$ $\infty^0$，$0^0$常用${u(x)}^{v(x)}=e^{v(x)\ln u(x)}$3. 第三类：$\infty-\infty$ 有分母时通分化成前两种情况。 没有分母倒代换构造分母。]]></content>
      <categories>
        <category>微积分</category>
      </categories>
      <tags>
        <tag>微积分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用泰勒、微积分公式]]></title>
    <url>%2F2017%2F10%2F27%2F%E5%B8%B8%E7%94%A8%E6%B3%B0%E5%8B%92%E3%80%81%E5%BE%AE%E7%A7%AF%E5%88%86%E5%85%AC%E5%BC%8F%E3%80%81%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[常用公式常用穷小替换$x=&gt;\sin x=&gt;\tan x=&gt;\arcsin x=&gt;\arctan x=&gt;\ln (x+1)=&gt;e^x-1$$(x+1)^a-1=&gt;ax$$a^x-1=&gt;xln(a)$$1-\cos x=&gt;\frac{1}{2}x^2$$\tan x-\sin x=&gt;\tan x(1-\cos x)=&gt;\frac{1}{2}x^3$ 常用泰勒展开式 $x-f(x)$展开$x-\sin x=\frac{1}{6}x^3+o(x^3)$$x-\arcsin x=-\frac{1}{6}x^3+o(x^3)$$x-\tan x=-\frac{1}{3}x^3+o(x^3)$$x-\arctan x=\frac{1}{3}x^3+o(x^3)$ 三角函数展开$e^x=1+x+\frac{x^2}{2!}+\frac{x^3}{3!}+o(x^3)$$\sin x=x-\frac{x^3}{3!}+\frac{x^5}{5!}+o(x^5)$$\cos x=1-\frac{x^2}{2!}+\frac{x^4}{4!}+o(x^4)$$\ln(x+1)=x-\frac{1}{2}x^2+\frac{1}{3}x^3+o(x^3)$常用微分公式$d\tan x=(\sec x)^2dx$$d\cot x=-(\csc x)^2dx$$d\sec x=\sec x\tan xdx$$d\csc x=-\csc x\cot xdx$$d\arcsin x=\frac{1}{\sqrt{1-x^2}}dx$$d\arccos x=-\frac{1}{\sqrt{1-x^2}}dx$$d\arctan x=\frac{1}{1+x^2}dx$$darcot x=-\frac{1}{1+x^2}dx$ 常用高阶导数公式$(e^{ax})^{(n)}=a^ne^{an}$$(\sin ax)^{(n)}=a^n\sin (ax+n\frac{\Pi}{2})$$(\cos ax)^{(n)}=a^n\cos (ax+n\frac{\Pi}{2})$$(\ln (1+x))^{(n)}=(-1)^{n-1}\frac{(n-1)!}{(x+1)^n}$$(\frac{1}{x})^{(n)}=(-1)^n\frac{n!}{x^{n+1}}$ 莱布尼茨公式$(uv)^{(n)}=u^{(n)}v+C_n^1u^{(n-1)}v+C_n^ku^{(n-k)}v^{(k)}+uv^{n}$ 常用积分公式$\int \tan xdx=-\ln|\cos x|+C$$\int \cot xdx=\ln|\sin x|+C$$\int \sec xdx=\ln\left|\sec x+\tan x\right|+C$$\int \csc x dx=\ln\left|\csc x-\cot x\right|+C$$\int \sec^2(x)dx=\tan x+C$$\int \csc xdx=\cot x+C$$\int \frac{1}{a^2+x^2}dx=\frac{1}{a}\tan(\frac{1}{a}x)+C$$\int \frac{1}{a^2-x^2}dx=\ln\left|\frac{a+x}{a-x}\right|+C$$\int \frac{1}{\sqrt{a^2-x^2}}dx=\arcsin\frac{1}{a}x$$\int \frac{1}{\sqrt{x^2\pm a^2}}dx=\ln|x+\sqrt{x^2\pm a^2}|+C$$\int \ln xdx=x\ln x-x+C$Mathmatica常用命令 Solve[x^2 + a x + 1 == 0, x]求方程的解 Integrate[f,x,x_min,x_max]求定积分和不定积分 Limit[Sin[x]/x, x -&gt; 0]求极限]]></content>
      <categories>
        <category>微积分</category>
      </categories>
      <tags>
        <tag>微积分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CRC冗余码]]></title>
    <url>%2F2017%2F10%2F26%2FCRC%E5%86%97%E4%BD%99%E7%A0%81%2F</url>
    <content type="text"><![CDATA[CRC校验基本原理CRC检验原理实际上就是在一个p位二进制数据序列之后附加一个r位二进制检验码(序列)，从而构成一个总长为n＝p＋r位的二进制序列；附加在数据序列之后的这个检验码与数据序列的内容之间存在着某种特定的关系。如果因干扰等原因使数据序列中的某一位或某些位发生错误，这种特定关系就会被破坏。因此，通过检查这一关系，就可以实现对数据正确性的检验。 几个基本概念 帧检验序列FCS（Frame Check Sequence）：为了进行差错检验而添加的冗余码。 多项式模2运行：实际上是按位异或(Exclusive OR)运算，即相同为0，相异为1，也就是不考虑进位、借位的二进制加减运算。如：$10011011 + 11001010 = 01010001$。 生成多项式（generator polynomial）：当进行CRC检验时，发送方与接收方需要事先约定一个除数，即生成多项式，一般记作$G(x)$。生成多项式的最高位与最低位必须是1。常用的CRC码的生成多项式有：$CRC8=X^8+X^5+X4+1$$CRC-CCITT=X^16+X^12+X^5+1$$CRC16=X^16+X^15+X^5+1$$CRC12=X^12+X^11+X^3+X^2+1$$CRC32=X^32+X^26+X^23+X^22+X^16+X^12+X^11+X^10+X^8+X^7+X^5+X^4+X^2+X^1+1$每一个生成多项式都可以与一个代码相对应，如CRC8对应代码：100110001。CRC检验码的计算设信息字段为K位，校验字段为R位，则码字长度为$N(N=K+R)$。设双方事先约定了一个R次多项式$g(x)$，则CRC码：$V(x)=A(x)g(x)=xRm(x)+r(x)$其中:$m(x)$为K次信息多项式， $r(x)$为$R-1$次校验多项式。这里$r(x)$对应的代码即为冗余码，加在原信息字段后即形成CRC码。r(x)的计算方法为：在K位信息字段的后面添加R个0，再除以$g(x)$对应的代码序列，得到的余数即为$r(x)$对应的代码(应为R－1位；若不足，而在高位补0)。 计算示例 这里$g(x)=11001$，生成的CRC冗余码为$1010$，最终得到的码字是$1011001010$即码字 = 被除 + 数冗余码。错误检测当接收方收到数据后，用收到的数据对P（事先约定的）进行模2除法，若余数为0，则认为数据传输无差错；若余数不为0，则认为数据传输出现了错误，由于不知道错误发生在什么地方，因而不能进行自动纠正，一般的做法是丢弃接收的数据。 Note CRC是一种常用的检错码，并不能用于自动纠错。 只要经过严格的挑选，并使用位数足够多的除数 P，那么出现检测不到的差错的概率就很小很小。 仅用循环冗余检验 CRC 差错检测技术只能做到无差错接受（只是非常近似的认为是无差错的），并不能保证可靠传输。]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用jieba和wordcloud生成词云]]></title>
    <url>%2F2017%2F10%2F26%2F%E5%88%A9%E7%94%A8jieba%E5%92%8Cwordcloud%E7%94%9F%E6%88%90%E8%AF%8D%E4%BA%91%2F</url>
    <content type="text"><![CDATA[利用wordcloud和jieba做一个词云环境使用到的轮子：matplotlib，jieba，scipy，wordcloud，numpy，PIL。python2对jieba的中文分词支持不是很好，所以使用python3。1234567python 3.6.1jieba 0.39matplotlib 1.0.4scipy 1.0.0wordcloud 1.3.1numpy 1.13.3PIL 1.1.6 Github源代码具体实现导入轮子1234567#encoding=utf-8import jiebaimport matplotlib.pyplot as pltfrom scipy.misc import imreadfrom wordcloud import WordCloud, STOPWORDS, ImageColorGeneratorimport numpy as npfrom PIL import Image 所用到的库都能用pip3安装。 生成分词123text_from_file=open('data.txt','r').read()Word_spilt_jieba = jieba.cut(text_from_file,cut_all = False)word_space = ' '.join(Word_spilt_jieba) 数据是从网上复制了几份十九大，国庆，小说的内容，从文本中读入数据到text，用jieba进行分词，不使用全模式，全模式匹配会出现重复关键词的现象，使用后效果并不好。 自定义词云背景12img=imread('bipt.jpg')img = np.array(Image.open('bipt.jpg')) 设置生成词云的背景，这里用到了numpy将图片转换为矩阵，图片需要自己下载定义背景。 生成词云12345678910my_wordcloud = WordCloud( background_color='white', #设置背景颜色 mask=img, #背景图片 max_words = 200, #设置最大显示的词数 stopwords = STOPWORDS, #设置停用词 #设置字体格式，字体格式 .ttf文件需自己网上下载，最好将名字改为英文，中文名路径加载会出现问题。 font_path = 'simkai.ttf', max_font_size = 100, #设置字体最大值 random_state=50, #设置随机生成状态，即多少种配色方案 ).generate(word_space) 设置wordcloud参数，注意这里有一个字体必须自己设置中文字体，否则生成的词云不能出现中文，我用到的是simkai.ttf，下载地址：simkai字体。 显示词云12345iamge_colors = ImageColorGenerator(img)plt.imshow(my_wordcloud)plt.axis('off')plt.show()my_wordcloud.to_file('res.jpg') 取图片的颜色作为词云的颜色，并显示词云。如下图]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[爬取QQ空间数据进行分析]]></title>
    <url>%2F2017%2F10%2F24%2F%E7%88%AC%E5%8F%96QQ%E7%A9%BA%E9%97%B4%E6%95%B0%E6%8D%AE%E8%BF%9B%E8%A1%8C%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[主要思路： 通过selenium+phantomjs模拟登录qq空间取到cookies和g_qzonetoken，并算出gtk 通过Requests库利用前面得到的url参数，构造http请求 分析请求得到的响应，是一个json，利用正则表达式提取字段 设计数据表，并将提取到的字段插入到数据库中 通过qq邮箱中的导出联系人功能，把好友的qq号导出到一个csv文件，遍历所有的qq号爬取所有的说说 通过sql查询和ipython分析数据，并将数据可视化 通过python的第三方库jieba、wordcloud基于说说的内容做一个词云 通过selenium+phantomjs模拟登录qq空间取到cookies和g_qzonetoken，并算出gtk具体实现1234567891011121314151617181920212223242526272829303132333435import refrom selenium import webdriverfrom time import sleepfrom PIL import Image#定义登录函数def QR_login(): def getGTK(cookie): """ 根据cookie得到GTK """ hashes = 5381 for letter in cookie['p_skey']: hashes += (hashes &lt;&lt; 5) + ord(letter)return hashes &amp; 0x7fffffff browser=webdriver.PhantomJS(executable_path="D:\phantomjs.exe")#这里要输入你的phantomjs所在的路径 url="https://qzone.qq.com/"#QQ登录网址 browser.get(url) browser.maximize_window()#全屏 sleep(3)#等三秒 browser.get_screenshot_as_file('QR.png')#截屏并保存图片 im = Image.open('QR.png')#打开图片 im.show()#用手机扫二维码登录qq空间 sleep(20)#等二十秒，可根据自己的网速和性能修改 print(browser.title)#打印网页标题 cookie = &#123;&#125;#初始化cookie字典 for elem in browser.get_cookies():#取cookies cookie[elem['name']] = elem['value']print('Get the cookie of QQlogin successfully!(共%d个键值对)' % (len(cookie))) html = browser.page_source#保存网页源码 g_qzonetoken=re.search(r'window\.g_qzonetoken = \(function\(\)\&#123; try\&#123;return (.*?);\&#125; catch\(e\)',html)#从网页源码中提取g_qzonetoken gtk=getGTK(cookie)#通过getGTK函数计算gtk browser.quit()return (cookie,gtk,g_qzonetoken.group(1))if __name__=="__main__": QR_login() 通过火狐浏览器的一个叫json-dataview的插件可以看到这个响应是一个json格式的12345678910111213141516171819202122232425262728293031323334353637383940414243444546def parse_mood(i): '''从返回的json中，提取我们想要的字段''' text = re.sub('"commentlist":.*?"conlist":', '', i)if text: myMood = &#123;&#125; myMood["isTransfered"] = False tid = re.findall('"t1_termtype":.*?"tid":"(.*?)"', text)[0] # 获取说说ID tid = qq + '_' + tid myMood['id'] = tid myMood['pos_y'] = 0 myMood['pos_x'] = 0 mood_cont = re.findall('\],"content":"(.*?)"', text)if re.findall('&#125;,"name":"(.*?)",', text): name = re.findall('&#125;,"name":"(.*?)",', text)[0] myMood['name'] = nameif len(mood_cont) == 2: # 如果长度为2则判断为属于转载 myMood["Mood_cont"] = "评语:" + mood_cont[0] + "---------&gt;转载内容:" + mood_cont[1] # 说说内容 myMood["isTransfered"] = True elif len(mood_cont) == 1: myMood["Mood_cont"] = mood_cont[0]else: myMood["Mood_cont"] = "" if re.findall('"created_time":(\d+)', text): created_time = re.findall('"created_time":(\d+)', text)[0] temp_pubTime = datetime.datetime.fromtimestamp(int(created_time)) temp_pubTime = temp_pubTime.strftime("%Y-%m-%d %H:%M:%S") dt = temp_pubTime.split(' ') time = dt[1] myMood['time'] = time date = dt[0] myMood['date'] = dateif re.findall('"source_name":"(.*?)"', text): source_name = re.findall('"source_name":"(.*?)"', text)[0] # 获取发表的工具（如某手机） myMood['tool'] = source_nameif re.findall('"pos_x":"(.*?)"', text):#获取经纬度坐标 pos_x = re.findall('"pos_x":"(.*?)"', text)[0] pos_y = re.findall('"pos_y":"(.*?)"', text)[0]if pos_x: myMood['pos_x'] = pos_xif pos_y: myMood['pos_y'] = pos_y idname = re.findall('"idname":"(.*?)"', text)[0] myMood['idneme'] = idname cmtnum = re.findall('"cmtnum":(.*?),', text)[0] myMood['cmtnum'] = cmtnumreturn myMood#返回一个字典 我们想要的东西已经提取出来了，接下来需要设计数据表，通过navicat可以很方便的建表，然后通过python连接mysql数据库，写入数据。这是创建数据表的sql代码1234567891011121314CREATE TABLE `mood` (`name` varchar(80) DEFAULT NULL,`date` date DEFAULT NULL,`content` text,`comments_num` int(11) DEFAULT NULL,`time` time DEFAULT NULL,`tool` varchar(255) DEFAULT NULL,`id` varchar(255) NOT NULL,`sitename` varchar(255) DEFAULT NULL,`pox_x` varchar(30) DEFAULT NULL,`pox_y` varchar(30) DEFAULT NULL,`isTransfered` double DEFAULT NULL,PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; 其实到这里爬虫的主要的代码就算完了，之后主要是通过QQ邮箱的联系人导出功能，构建url列表，最后等着它运行完成就可以了。这里我单线程爬200多个好友用了大约三个小时，拿到了十万条说说。下面是爬虫的主体代码。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#从csv文件中取qq号，并保存在一个列表中csv_reader = csv.reader(open('qq.csv'))friend=[]for row in csv_reader: friend.append(row[3])friend.pop(0)friends=[]for f in friend: f=f[:-7] friends.append(f)headers=&#123;'Host': 'h5.qzone.qq.com', 'User-Agent': 'Mozilla/5.0 (Windows NT 6.1; WOW64; rv:53.0) Gecko/20100101 Firefox/53.0', 'Accept': '*/*', 'Accept-Language':'zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3', 'Accept-Encoding': 'gzip, deflate, br', 'Referer': 'https://user.qzone.qq.com/790178228?_t_=0.22746974226377736', 'Connection':'keep-alive'&#125;#伪造浏览器头conn = MySQLdb.connect('localhost', 'root', '123456', 'qq_mood', charset="utf8", use_unicode=True)#连接mysql数据库cursor = conn.cursor()#定义游标cookie,gtk,qzonetoken=QRlogin#通过登录函数取得cookies，gtk，qzonetokens=requests.session()#用requests初始化会话for qq in friends:#遍历qq号列表 for p in range(0,1000): pos=p*20 params=&#123;'uin':qq, 'ftype':'0', 'sort':'0', 'pos':pos, 'num':'20', 'replynum':'100', 'g_tk':gtk, 'callback':'_preloadCallback', 'code_version':'1', 'format':'jsonp', 'need_private_comment':'1', 'qzonetoken':qzonetoken &#125; response=s.request('GET','https://h5.qzone.qq.com/proxy/domain/taotao.qq.com/cgi-bin/emotion_cgi_msglist_v6',params=params,headers=headers,cookies=cookie)print(response.status_code)#通过打印状态码判断是否请求成功 text=response.text#读取响应内容 if not re.search('lbs', text):#通过lbs判断此qq的说说是否爬取完毕 print('%s说说下载完成'% qq)break textlist = re.split('\&#123;"certified"', text)[1:]for i in textlist: myMood=parse_mood(i)'''将提取的字段值插入mysql数据库，通过用异常处理防止个别的小bug中断爬虫，开始的时候可以先不用异常处理判断是否能正常插入数据库''' try: insert_sql = ''' insert into mood(id,content,time,sitename,pox_x,pox_y,tool,comments_num,date,isTransfered,name) VALUES (%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s) ''' cursor.execute(insert_sql, (myMood['id'],myMood["Mood_cont"],myMood['time'],myMood['idneme'],myMood['pos_x'],myMood['pos_y'],myMood['tool'],myMood['cmtnum'],myMood['date'],myMood["isTransfered"],myMood['name'])) conn.commit()except: passprint('说说全部下载完成！') 数据分析学生QQ用的多还是微信用的多？ 先用sql进行聚合分析，然后通过ipython作图，将数据可视化。统计一年之中每天的说说数目，可以发现每年除夕这一天是大家发说说最多的一天，可以看出2015年9月达到了一个高峰，主要因为数据是2015级的，所以在2015年九月大学入学的，之后开始下降，好多人开始玩微信，逐渐放弃了QQ，所以北石化学生用微信还是多。 通过下面这个年变化图可以更直观的看出QQ使用的频率越来越少，可能因为大学里班级，社团，活动有很多的微信群，越来越少的北石化学生使用QQ。 学生晚上几点睡觉？通过这个每小时段说说发表的数目柱形图，可以发现大家在晚上22点到23点左右是最多的，另外中午十二点到一点也有一个小高峰!由此可见大多数学生在宿舍十一点熄灯后，并不会按时睡觉。 学生的经济情况怎么样？用Excel的内容筛选功能，做了一个手机类型的饼图，通过这个饼图可以看出使用最多的手机是苹果，小米，魅族，华为这四个手机品牌，说明大多数大学生还是比较倾向于性价比比较高的手机，从某一方面可以体现大多数同学还是中等生活水平。 学生都在说些什么？通过将mood表中的content字段导出为txt文本文件，利用python的jieba和wordcloud这两个第三方库，可以生成基于说说内容的词云.看看大家在国庆期间都再说些什么，很明显关于，习近平主席，国庆节，人民英雄纪念碑等关键词明显增多，同样也有计算机，英语，考试等关于学习的字段。 ，]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python写一个简单的神经网络]]></title>
    <url>%2F2017%2F10%2F21%2FPython%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E7%AD%94%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%2F</url>
    <content type="text"><![CDATA[简单的神经网络算法，包括基本的后向传播BP算法，前向传播算法，更新权重使用的梯度下降算法，基本的框架算是有了，学习使用。注意输入每一行数据时候在神经网络中会加入bias偏量，神经网络的层数和每层个数为自定义，搞了很久才知道输入矩阵多了一个维度，权重和后向传播更新的delta都是每列神经元之间的关系，关于s形函数暂时用了两种，分别是logistic() 和 tanh() 效果差不多，简单的模型作为笔记学习使用。 获取源码Github源码在这里 具体实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576import numpy as npdef tanh(x): return np.tanh(x)def tanh_deriv(x): return 1.0 - np.tanh(x) * np.tanh(x)def logistic(x): return 1 / (1 + np.exp(-x))def logistic_derivative(x): return logistic(x) * (1 - logistic(x))class NeuralNetwork: def __init__(self, layers, activation='tanh'): if activation == 'logistic': self.activation = logistic self.activation_deriv = logistic_derivative elif activation == 'tanh': self.activation = tanh self.activation_deriv = tanh_deriv self.weights = [] for i in range(1, len(layers) - 1): self.weights.append( (2 * np.random.random((layers[i - 1] + 1, layers[i] + 1)) - 1) * 0.25) self.weights.append( (2 * np.random.random((layers[-2] + 1, layers[-1])) - 1) * 0.25) def fit(self, X, y, learning_rate=0.2, epochs=10000): X = np.atleast_2d(X) temp = np.ones([X.shape[0], X.shape[1] + 1]) temp[:, 0:-1] = X # adding the bias unit to the input layer X = temp y = np.array(y) for k in range(epochs): i = np.random.randint(X.shape[0]) a = [X[i]] for l in range(len(self.weights)): # going forward network, for each layer a.append(self.activation(np.dot(a[l], self.weights[l]))) error = y[i] - a[-1] # Computer the error at the top layer # For output layer, Err calculation (delta is updated error) deltas = [error * self.activation_deriv(a[-1])] # Staring backprobagation for l in range(len(a) - 2, 0, -1): deltas.append(deltas[-1].dot(self.weights[l].T) * self.activation_deriv(a[l])) deltas.reverse() for i in range(len(self.weights)): layer = np.atleast_2d(a[i]) delta = np.atleast_2d(deltas[i]) self.weights[i] += learning_rate * layer.T.dot(delta) def predict(self, x): x = np.array(x) temp = np.ones(x.shape[0] + 1) temp[0:-1] = x a = temp for l in range(0, len(self.weights)): a = self.activation(np.dot(a, self.weights[l])) return ann = NeuralNetwork([2, 2, 3, 1], 'tanh')X = np.array([[0, 0], [0, 1], [1, 0], [1, 1]])y = np.array([0, 1, 1, 0])nn.fit(X, y)for i in [[0, 0], [0, 1], [1, 0], [1, 1]]: print(i, nn.predict(i))]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
</search>
